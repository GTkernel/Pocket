// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: yolo.proto
#ifndef GRPC_yolo_2eproto__INCLUDED
#define GRPC_yolo_2eproto__INCLUDED

#include "yolo.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace yolo_tf {

class YoloTensorflowWrapper final {
 public:
  static constexpr char const* service_full_name() {
    return "yolo_tf.YoloTensorflowWrapper";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Control Procedures
    virtual ::grpc::Status Connect(::grpc::ClientContext* context, const ::yolo_tf::ConnectRequest& request, ::yolo_tf::ConnectResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ConnectResponse>> AsyncConnect(::grpc::ClientContext* context, const ::yolo_tf::ConnectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ConnectResponse>>(AsyncConnectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ConnectResponse>> PrepareAsyncConnect(::grpc::ClientContext* context, const ::yolo_tf::ConnectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ConnectResponse>>(PrepareAsyncConnectRaw(context, request, cq));
    }
    virtual ::grpc::Status Disconnect(::grpc::ClientContext* context, const ::yolo_tf::DisconnectRequest& request, ::yolo_tf::DisconnectResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::DisconnectResponse>> AsyncDisconnect(::grpc::ClientContext* context, const ::yolo_tf::DisconnectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::DisconnectResponse>>(AsyncDisconnectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::DisconnectResponse>> PrepareAsyncDisconnect(::grpc::ClientContext* context, const ::yolo_tf::DisconnectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::DisconnectResponse>>(PrepareAsyncDisconnectRaw(context, request, cq));
    }
    // TF Wrappers
    virtual ::grpc::Status SayHello(::grpc::ClientContext* context, const ::yolo_tf::HelloRequest& request, ::yolo_tf::HelloReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::HelloReply>> AsyncSayHello(::grpc::ClientContext* context, const ::yolo_tf::HelloRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::HelloReply>>(AsyncSayHelloRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::HelloReply>> PrepareAsyncSayHello(::grpc::ClientContext* context, const ::yolo_tf::HelloRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::HelloReply>>(PrepareAsyncSayHelloRaw(context, request, cq));
    }
    virtual ::grpc::Status callable_emulator(::grpc::ClientContext* context, const ::yolo_tf::CallRequest& request, ::yolo_tf::CallResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::CallResponse>> Asynccallable_emulator(::grpc::ClientContext* context, const ::yolo_tf::CallRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::CallResponse>>(Asynccallable_emulatorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::CallResponse>> PrepareAsynccallable_emulator(::grpc::ClientContext* context, const ::yolo_tf::CallRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::CallResponse>>(PrepareAsynccallable_emulatorRaw(context, request, cq));
    }
    virtual ::grpc::Status get_iterable_slicing(::grpc::ClientContext* context, const ::yolo_tf::SlicingRequest& request, ::yolo_tf::SlicingResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::SlicingResponse>> Asyncget_iterable_slicing(::grpc::ClientContext* context, const ::yolo_tf::SlicingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::SlicingResponse>>(Asyncget_iterable_slicingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::SlicingResponse>> PrepareAsyncget_iterable_slicing(::grpc::ClientContext* context, const ::yolo_tf::SlicingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::SlicingResponse>>(PrepareAsyncget_iterable_slicingRaw(context, request, cq));
    }
    virtual ::grpc::Status constant(::grpc::ClientContext* context, const ::yolo_tf::ConstantRequest& request, ::yolo_tf::ConstantResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ConstantResponse>> Asyncconstant(::grpc::ClientContext* context, const ::yolo_tf::ConstantRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ConstantResponse>>(AsyncconstantRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ConstantResponse>> PrepareAsyncconstant(::grpc::ClientContext* context, const ::yolo_tf::ConstantRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ConstantResponse>>(PrepareAsyncconstantRaw(context, request, cq));
    }
    virtual ::grpc::Status config_experimental_list__physical__devices(::grpc::ClientContext* context, const ::yolo_tf::DeviceType& request, ::yolo_tf::PhysicalDevices* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::PhysicalDevices>> Asyncconfig_experimental_list__physical__devices(::grpc::ClientContext* context, const ::yolo_tf::DeviceType& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::PhysicalDevices>>(Asyncconfig_experimental_list__physical__devicesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::PhysicalDevices>> PrepareAsyncconfig_experimental_list__physical__devices(::grpc::ClientContext* context, const ::yolo_tf::DeviceType& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::PhysicalDevices>>(PrepareAsyncconfig_experimental_list__physical__devicesRaw(context, request, cq));
    }
    virtual ::grpc::Status image_decode__image(::grpc::ClientContext* context, const ::yolo_tf::DecodeImageRequest& request, ::yolo_tf::DecodeImageResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::DecodeImageResponse>> Asyncimage_decode__image(::grpc::ClientContext* context, const ::yolo_tf::DecodeImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::DecodeImageResponse>>(Asyncimage_decode__imageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::DecodeImageResponse>> PrepareAsyncimage_decode__image(::grpc::ClientContext* context, const ::yolo_tf::DecodeImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::DecodeImageResponse>>(PrepareAsyncimage_decode__imageRaw(context, request, cq));
    }
    virtual ::grpc::Status expand__dims(::grpc::ClientContext* context, const ::yolo_tf::ExpandDemensionRequest& request, ::yolo_tf::ExpandDemensionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ExpandDemensionResponse>> Asyncexpand__dims(::grpc::ClientContext* context, const ::yolo_tf::ExpandDemensionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ExpandDemensionResponse>>(Asyncexpand__dimsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ExpandDemensionResponse>> PrepareAsyncexpand__dims(::grpc::ClientContext* context, const ::yolo_tf::ExpandDemensionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ExpandDemensionResponse>>(PrepareAsyncexpand__dimsRaw(context, request, cq));
    }
    virtual ::grpc::Status keras_layers_Input(::grpc::ClientContext* context, const ::yolo_tf::InputRequest& request, ::yolo_tf::InputResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::InputResponse>> Asynckeras_layers_Input(::grpc::ClientContext* context, const ::yolo_tf::InputRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::InputResponse>>(Asynckeras_layers_InputRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::InputResponse>> PrepareAsynckeras_layers_Input(::grpc::ClientContext* context, const ::yolo_tf::InputRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::InputResponse>>(PrepareAsynckeras_layers_InputRaw(context, request, cq));
    }
    virtual ::grpc::Status keras_Model(::grpc::ClientContext* context, const ::yolo_tf::ModelRequest& request, ::yolo_tf::ModelResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ModelResponse>> Asynckeras_Model(::grpc::ClientContext* context, const ::yolo_tf::ModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ModelResponse>>(Asynckeras_ModelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ModelResponse>> PrepareAsynckeras_Model(::grpc::ClientContext* context, const ::yolo_tf::ModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ModelResponse>>(PrepareAsynckeras_ModelRaw(context, request, cq));
    }
    virtual ::grpc::Status keras_layers_ZeroPadding2D(::grpc::ClientContext* context, const ::yolo_tf::ZeroPadding2DRequest& request, ::yolo_tf::ZeroPadding2DResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ZeroPadding2DResponse>> Asynckeras_layers_ZeroPadding2D(::grpc::ClientContext* context, const ::yolo_tf::ZeroPadding2DRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ZeroPadding2DResponse>>(Asynckeras_layers_ZeroPadding2DRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ZeroPadding2DResponse>> PrepareAsynckeras_layers_ZeroPadding2D(::grpc::ClientContext* context, const ::yolo_tf::ZeroPadding2DRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ZeroPadding2DResponse>>(PrepareAsynckeras_layers_ZeroPadding2DRaw(context, request, cq));
    }
    virtual ::grpc::Status keras_layers_Conv2D(::grpc::ClientContext* context, const ::yolo_tf::Conv2DRequest& request, ::yolo_tf::Conv2DResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::Conv2DResponse>> Asynckeras_layers_Conv2D(::grpc::ClientContext* context, const ::yolo_tf::Conv2DRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::Conv2DResponse>>(Asynckeras_layers_Conv2DRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::Conv2DResponse>> PrepareAsynckeras_layers_Conv2D(::grpc::ClientContext* context, const ::yolo_tf::Conv2DRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::Conv2DResponse>>(PrepareAsynckeras_layers_Conv2DRaw(context, request, cq));
    }
    virtual ::grpc::Status keras_layers_LeakyReLU(::grpc::ClientContext* context, const ::yolo_tf::LeakyReluRequest& request, ::yolo_tf::LeakyReluResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::LeakyReluResponse>> Asynckeras_layers_LeakyReLU(::grpc::ClientContext* context, const ::yolo_tf::LeakyReluRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::LeakyReluResponse>>(Asynckeras_layers_LeakyReLURaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::LeakyReluResponse>> PrepareAsynckeras_layers_LeakyReLU(::grpc::ClientContext* context, const ::yolo_tf::LeakyReluRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::LeakyReluResponse>>(PrepareAsynckeras_layers_LeakyReLURaw(context, request, cq));
    }
    virtual ::grpc::Status keras_layers_Add(::grpc::ClientContext* context, const ::yolo_tf::AddRequest& request, ::yolo_tf::AddResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::AddResponse>> Asynckeras_layers_Add(::grpc::ClientContext* context, const ::yolo_tf::AddRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::AddResponse>>(Asynckeras_layers_AddRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::AddResponse>> PrepareAsynckeras_layers_Add(::grpc::ClientContext* context, const ::yolo_tf::AddRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::AddResponse>>(PrepareAsynckeras_layers_AddRaw(context, request, cq));
    }
    virtual ::grpc::Status keras_layers_Lambda(::grpc::ClientContext* context, const ::yolo_tf::LambdaRequest& request, ::yolo_tf::LambdaResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::LambdaResponse>> Asynckeras_layers_Lambda(::grpc::ClientContext* context, const ::yolo_tf::LambdaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::LambdaResponse>>(Asynckeras_layers_LambdaRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::LambdaResponse>> PrepareAsynckeras_layers_Lambda(::grpc::ClientContext* context, const ::yolo_tf::LambdaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::LambdaResponse>>(PrepareAsynckeras_layers_LambdaRaw(context, request, cq));
    }
    virtual ::grpc::Status keras_layers_UpSampling2D(::grpc::ClientContext* context, const ::yolo_tf::UpSampling2DRequest& request, ::yolo_tf::UpSampling2DResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::UpSampling2DResponse>> Asynckeras_layers_UpSampling2D(::grpc::ClientContext* context, const ::yolo_tf::UpSampling2DRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::UpSampling2DResponse>>(Asynckeras_layers_UpSampling2DRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::UpSampling2DResponse>> PrepareAsynckeras_layers_UpSampling2D(::grpc::ClientContext* context, const ::yolo_tf::UpSampling2DRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::UpSampling2DResponse>>(PrepareAsynckeras_layers_UpSampling2DRaw(context, request, cq));
    }
    virtual ::grpc::Status keras_layers_Concatenate(::grpc::ClientContext* context, const ::yolo_tf::ConcatenateRequest& request, ::yolo_tf::ContcatenateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ContcatenateResponse>> Asynckeras_layers_Concatenate(::grpc::ClientContext* context, const ::yolo_tf::ConcatenateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ContcatenateResponse>>(Asynckeras_layers_ConcatenateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ContcatenateResponse>> PrepareAsynckeras_layers_Concatenate(::grpc::ClientContext* context, const ::yolo_tf::ConcatenateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ContcatenateResponse>>(PrepareAsynckeras_layers_ConcatenateRaw(context, request, cq));
    }
    virtual ::grpc::Status image_resize(::grpc::ClientContext* context, const ::yolo_tf::ImageResizeRequest& request, ::yolo_tf::ImageResizeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ImageResizeResponse>> Asyncimage_resize(::grpc::ClientContext* context, const ::yolo_tf::ImageResizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ImageResizeResponse>>(Asyncimage_resizeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ImageResizeResponse>> PrepareAsyncimage_resize(::grpc::ClientContext* context, const ::yolo_tf::ImageResizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ImageResizeResponse>>(PrepareAsyncimage_resizeRaw(context, request, cq));
    }
    virtual ::grpc::Status keras_regularizers_l2(::grpc::ClientContext* context, const ::yolo_tf::l2Request& request, ::yolo_tf::l2Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::l2Response>> Asynckeras_regularizers_l2(::grpc::ClientContext* context, const ::yolo_tf::l2Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::l2Response>>(Asynckeras_regularizers_l2Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::l2Response>> PrepareAsynckeras_regularizers_l2(::grpc::ClientContext* context, const ::yolo_tf::l2Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::l2Response>>(PrepareAsynckeras_regularizers_l2Raw(context, request, cq));
    }
    // attribute getters
    virtual ::grpc::Status attribute_tensor_shape(::grpc::ClientContext* context, const ::yolo_tf::TensorShapeRequest& request, ::yolo_tf::TensorShapeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::TensorShapeResponse>> Asyncattribute_tensor_shape(::grpc::ClientContext* context, const ::yolo_tf::TensorShapeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::TensorShapeResponse>>(Asyncattribute_tensor_shapeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::TensorShapeResponse>> PrepareAsyncattribute_tensor_shape(::grpc::ClientContext* context, const ::yolo_tf::TensorShapeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::TensorShapeResponse>>(PrepareAsyncattribute_tensor_shapeRaw(context, request, cq));
    }
    virtual ::grpc::Status attribute_model_load__weight(::grpc::ClientContext* context, const ::yolo_tf::LoadWeightsRequest& request, ::yolo_tf::LoadWeightsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::LoadWeightsResponse>> Asyncattribute_model_load__weight(::grpc::ClientContext* context, const ::yolo_tf::LoadWeightsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::LoadWeightsResponse>>(Asyncattribute_model_load__weightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::LoadWeightsResponse>> PrepareAsyncattribute_model_load__weight(::grpc::ClientContext* context, const ::yolo_tf::LoadWeightsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::LoadWeightsResponse>>(PrepareAsyncattribute_model_load__weightRaw(context, request, cq));
    }
    virtual ::grpc::Status attribute_checkpoint_expect__partial(::grpc::ClientContext* context, const ::yolo_tf::ExpectPartialRequest& request, ::yolo_tf::ExpectPartialResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ExpectPartialResponse>> Asyncattribute_checkpoint_expect__partial(::grpc::ClientContext* context, const ::yolo_tf::ExpectPartialRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ExpectPartialResponse>>(Asyncattribute_checkpoint_expect__partialRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ExpectPartialResponse>> PrepareAsyncattribute_checkpoint_expect__partial(::grpc::ClientContext* context, const ::yolo_tf::ExpectPartialRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ExpectPartialResponse>>(PrepareAsyncattribute_checkpoint_expect__partialRaw(context, request, cq));
    }
    // tensor operations
    virtual ::grpc::Status tensor_op_divide(::grpc::ClientContext* context, const ::yolo_tf::DivideRequest& request, ::yolo_tf::DivideResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::DivideResponse>> Asynctensor_op_divide(::grpc::ClientContext* context, const ::yolo_tf::DivideRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::DivideResponse>>(Asynctensor_op_divideRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::DivideResponse>> PrepareAsynctensor_op_divide(::grpc::ClientContext* context, const ::yolo_tf::DivideRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::DivideResponse>>(PrepareAsynctensor_op_divideRaw(context, request, cq));
    }
    // common operations
    virtual ::grpc::Status iterable_indexing(::grpc::ClientContext* context, const ::yolo_tf::IndexingRequest& request, ::yolo_tf::IndexingResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::IndexingResponse>> Asynciterable_indexing(::grpc::ClientContext* context, const ::yolo_tf::IndexingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::IndexingResponse>>(Asynciterable_indexingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::IndexingResponse>> PrepareAsynciterable_indexing(::grpc::ClientContext* context, const ::yolo_tf::IndexingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::IndexingResponse>>(PrepareAsynciterable_indexingRaw(context, request, cq));
    }
    virtual ::grpc::Status byte_tensor_to_numpy(::grpc::ClientContext* context, const ::yolo_tf::TensorToNumpyRequest& request, ::yolo_tf::TensorToNumPyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::TensorToNumPyResponse>> Asyncbyte_tensor_to_numpy(::grpc::ClientContext* context, const ::yolo_tf::TensorToNumpyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::TensorToNumPyResponse>>(Asyncbyte_tensor_to_numpyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::TensorToNumPyResponse>> PrepareAsyncbyte_tensor_to_numpy(::grpc::ClientContext* context, const ::yolo_tf::TensorToNumpyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::TensorToNumPyResponse>>(PrepareAsyncbyte_tensor_to_numpyRaw(context, request, cq));
    }
    virtual ::grpc::Status get_object_by_id(::grpc::ClientContext* context, const ::yolo_tf::GetObjectRequest& request, ::yolo_tf::GetObjectResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::GetObjectResponse>> Asyncget_object_by_id(::grpc::ClientContext* context, const ::yolo_tf::GetObjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::GetObjectResponse>>(Asyncget_object_by_idRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::GetObjectResponse>> PrepareAsyncget_object_by_id(::grpc::ClientContext* context, const ::yolo_tf::GetObjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::GetObjectResponse>>(PrepareAsyncget_object_by_idRaw(context, request, cq));
    }
    // YoloWrappers
    virtual ::grpc::Status batch_normalization(::grpc::ClientContext* context, const ::yolo_tf::BatchNormRequest& request, ::yolo_tf::BatchNormResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::BatchNormResponse>> Asyncbatch_normalization(::grpc::ClientContext* context, const ::yolo_tf::BatchNormRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::BatchNormResponse>>(Asyncbatch_normalizationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::BatchNormResponse>> PrepareAsyncbatch_normalization(::grpc::ClientContext* context, const ::yolo_tf::BatchNormRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::BatchNormResponse>>(PrepareAsyncbatch_normalizationRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Control Procedures
      virtual void Connect(::grpc::ClientContext* context, const ::yolo_tf::ConnectRequest* request, ::yolo_tf::ConnectResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Connect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ConnectResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Connect(::grpc::ClientContext* context, const ::yolo_tf::ConnectRequest* request, ::yolo_tf::ConnectResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Connect(::grpc::ClientContext* context, const ::yolo_tf::ConnectRequest* request, ::yolo_tf::ConnectResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Connect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ConnectResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Connect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ConnectResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void Disconnect(::grpc::ClientContext* context, const ::yolo_tf::DisconnectRequest* request, ::yolo_tf::DisconnectResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Disconnect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::DisconnectResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Disconnect(::grpc::ClientContext* context, const ::yolo_tf::DisconnectRequest* request, ::yolo_tf::DisconnectResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Disconnect(::grpc::ClientContext* context, const ::yolo_tf::DisconnectRequest* request, ::yolo_tf::DisconnectResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Disconnect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::DisconnectResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Disconnect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::DisconnectResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // TF Wrappers
      virtual void SayHello(::grpc::ClientContext* context, const ::yolo_tf::HelloRequest* request, ::yolo_tf::HelloReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SayHello(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::HelloReply* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SayHello(::grpc::ClientContext* context, const ::yolo_tf::HelloRequest* request, ::yolo_tf::HelloReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SayHello(::grpc::ClientContext* context, const ::yolo_tf::HelloRequest* request, ::yolo_tf::HelloReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SayHello(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::HelloReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SayHello(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::HelloReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void callable_emulator(::grpc::ClientContext* context, const ::yolo_tf::CallRequest* request, ::yolo_tf::CallResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void callable_emulator(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::CallResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void callable_emulator(::grpc::ClientContext* context, const ::yolo_tf::CallRequest* request, ::yolo_tf::CallResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void callable_emulator(::grpc::ClientContext* context, const ::yolo_tf::CallRequest* request, ::yolo_tf::CallResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void callable_emulator(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::CallResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void callable_emulator(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::CallResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void get_iterable_slicing(::grpc::ClientContext* context, const ::yolo_tf::SlicingRequest* request, ::yolo_tf::SlicingResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_iterable_slicing(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::SlicingResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_iterable_slicing(::grpc::ClientContext* context, const ::yolo_tf::SlicingRequest* request, ::yolo_tf::SlicingResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_iterable_slicing(::grpc::ClientContext* context, const ::yolo_tf::SlicingRequest* request, ::yolo_tf::SlicingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_iterable_slicing(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::SlicingResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_iterable_slicing(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::SlicingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void constant(::grpc::ClientContext* context, const ::yolo_tf::ConstantRequest* request, ::yolo_tf::ConstantResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void constant(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ConstantResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void constant(::grpc::ClientContext* context, const ::yolo_tf::ConstantRequest* request, ::yolo_tf::ConstantResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void constant(::grpc::ClientContext* context, const ::yolo_tf::ConstantRequest* request, ::yolo_tf::ConstantResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void constant(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ConstantResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void constant(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ConstantResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void config_experimental_list__physical__devices(::grpc::ClientContext* context, const ::yolo_tf::DeviceType* request, ::yolo_tf::PhysicalDevices* response, std::function<void(::grpc::Status)>) = 0;
      virtual void config_experimental_list__physical__devices(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::PhysicalDevices* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void config_experimental_list__physical__devices(::grpc::ClientContext* context, const ::yolo_tf::DeviceType* request, ::yolo_tf::PhysicalDevices* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void config_experimental_list__physical__devices(::grpc::ClientContext* context, const ::yolo_tf::DeviceType* request, ::yolo_tf::PhysicalDevices* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void config_experimental_list__physical__devices(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::PhysicalDevices* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void config_experimental_list__physical__devices(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::PhysicalDevices* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void image_decode__image(::grpc::ClientContext* context, const ::yolo_tf::DecodeImageRequest* request, ::yolo_tf::DecodeImageResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void image_decode__image(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::DecodeImageResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void image_decode__image(::grpc::ClientContext* context, const ::yolo_tf::DecodeImageRequest* request, ::yolo_tf::DecodeImageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void image_decode__image(::grpc::ClientContext* context, const ::yolo_tf::DecodeImageRequest* request, ::yolo_tf::DecodeImageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void image_decode__image(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::DecodeImageResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void image_decode__image(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::DecodeImageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void expand__dims(::grpc::ClientContext* context, const ::yolo_tf::ExpandDemensionRequest* request, ::yolo_tf::ExpandDemensionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void expand__dims(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ExpandDemensionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void expand__dims(::grpc::ClientContext* context, const ::yolo_tf::ExpandDemensionRequest* request, ::yolo_tf::ExpandDemensionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void expand__dims(::grpc::ClientContext* context, const ::yolo_tf::ExpandDemensionRequest* request, ::yolo_tf::ExpandDemensionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void expand__dims(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ExpandDemensionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void expand__dims(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ExpandDemensionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void keras_layers_Input(::grpc::ClientContext* context, const ::yolo_tf::InputRequest* request, ::yolo_tf::InputResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void keras_layers_Input(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::InputResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void keras_layers_Input(::grpc::ClientContext* context, const ::yolo_tf::InputRequest* request, ::yolo_tf::InputResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void keras_layers_Input(::grpc::ClientContext* context, const ::yolo_tf::InputRequest* request, ::yolo_tf::InputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void keras_layers_Input(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::InputResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void keras_layers_Input(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::InputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void keras_Model(::grpc::ClientContext* context, const ::yolo_tf::ModelRequest* request, ::yolo_tf::ModelResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void keras_Model(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ModelResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void keras_Model(::grpc::ClientContext* context, const ::yolo_tf::ModelRequest* request, ::yolo_tf::ModelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void keras_Model(::grpc::ClientContext* context, const ::yolo_tf::ModelRequest* request, ::yolo_tf::ModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void keras_Model(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ModelResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void keras_Model(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void keras_layers_ZeroPadding2D(::grpc::ClientContext* context, const ::yolo_tf::ZeroPadding2DRequest* request, ::yolo_tf::ZeroPadding2DResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void keras_layers_ZeroPadding2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ZeroPadding2DResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void keras_layers_ZeroPadding2D(::grpc::ClientContext* context, const ::yolo_tf::ZeroPadding2DRequest* request, ::yolo_tf::ZeroPadding2DResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void keras_layers_ZeroPadding2D(::grpc::ClientContext* context, const ::yolo_tf::ZeroPadding2DRequest* request, ::yolo_tf::ZeroPadding2DResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void keras_layers_ZeroPadding2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ZeroPadding2DResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void keras_layers_ZeroPadding2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ZeroPadding2DResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void keras_layers_Conv2D(::grpc::ClientContext* context, const ::yolo_tf::Conv2DRequest* request, ::yolo_tf::Conv2DResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void keras_layers_Conv2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::Conv2DResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void keras_layers_Conv2D(::grpc::ClientContext* context, const ::yolo_tf::Conv2DRequest* request, ::yolo_tf::Conv2DResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void keras_layers_Conv2D(::grpc::ClientContext* context, const ::yolo_tf::Conv2DRequest* request, ::yolo_tf::Conv2DResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void keras_layers_Conv2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::Conv2DResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void keras_layers_Conv2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::Conv2DResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void keras_layers_LeakyReLU(::grpc::ClientContext* context, const ::yolo_tf::LeakyReluRequest* request, ::yolo_tf::LeakyReluResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void keras_layers_LeakyReLU(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::LeakyReluResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void keras_layers_LeakyReLU(::grpc::ClientContext* context, const ::yolo_tf::LeakyReluRequest* request, ::yolo_tf::LeakyReluResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void keras_layers_LeakyReLU(::grpc::ClientContext* context, const ::yolo_tf::LeakyReluRequest* request, ::yolo_tf::LeakyReluResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void keras_layers_LeakyReLU(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::LeakyReluResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void keras_layers_LeakyReLU(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::LeakyReluResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void keras_layers_Add(::grpc::ClientContext* context, const ::yolo_tf::AddRequest* request, ::yolo_tf::AddResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void keras_layers_Add(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::AddResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void keras_layers_Add(::grpc::ClientContext* context, const ::yolo_tf::AddRequest* request, ::yolo_tf::AddResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void keras_layers_Add(::grpc::ClientContext* context, const ::yolo_tf::AddRequest* request, ::yolo_tf::AddResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void keras_layers_Add(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::AddResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void keras_layers_Add(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::AddResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void keras_layers_Lambda(::grpc::ClientContext* context, const ::yolo_tf::LambdaRequest* request, ::yolo_tf::LambdaResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void keras_layers_Lambda(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::LambdaResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void keras_layers_Lambda(::grpc::ClientContext* context, const ::yolo_tf::LambdaRequest* request, ::yolo_tf::LambdaResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void keras_layers_Lambda(::grpc::ClientContext* context, const ::yolo_tf::LambdaRequest* request, ::yolo_tf::LambdaResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void keras_layers_Lambda(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::LambdaResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void keras_layers_Lambda(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::LambdaResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void keras_layers_UpSampling2D(::grpc::ClientContext* context, const ::yolo_tf::UpSampling2DRequest* request, ::yolo_tf::UpSampling2DResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void keras_layers_UpSampling2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::UpSampling2DResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void keras_layers_UpSampling2D(::grpc::ClientContext* context, const ::yolo_tf::UpSampling2DRequest* request, ::yolo_tf::UpSampling2DResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void keras_layers_UpSampling2D(::grpc::ClientContext* context, const ::yolo_tf::UpSampling2DRequest* request, ::yolo_tf::UpSampling2DResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void keras_layers_UpSampling2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::UpSampling2DResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void keras_layers_UpSampling2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::UpSampling2DResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void keras_layers_Concatenate(::grpc::ClientContext* context, const ::yolo_tf::ConcatenateRequest* request, ::yolo_tf::ContcatenateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void keras_layers_Concatenate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ContcatenateResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void keras_layers_Concatenate(::grpc::ClientContext* context, const ::yolo_tf::ConcatenateRequest* request, ::yolo_tf::ContcatenateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void keras_layers_Concatenate(::grpc::ClientContext* context, const ::yolo_tf::ConcatenateRequest* request, ::yolo_tf::ContcatenateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void keras_layers_Concatenate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ContcatenateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void keras_layers_Concatenate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ContcatenateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void image_resize(::grpc::ClientContext* context, const ::yolo_tf::ImageResizeRequest* request, ::yolo_tf::ImageResizeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void image_resize(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ImageResizeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void image_resize(::grpc::ClientContext* context, const ::yolo_tf::ImageResizeRequest* request, ::yolo_tf::ImageResizeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void image_resize(::grpc::ClientContext* context, const ::yolo_tf::ImageResizeRequest* request, ::yolo_tf::ImageResizeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void image_resize(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ImageResizeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void image_resize(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ImageResizeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void keras_regularizers_l2(::grpc::ClientContext* context, const ::yolo_tf::l2Request* request, ::yolo_tf::l2Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void keras_regularizers_l2(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::l2Response* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void keras_regularizers_l2(::grpc::ClientContext* context, const ::yolo_tf::l2Request* request, ::yolo_tf::l2Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void keras_regularizers_l2(::grpc::ClientContext* context, const ::yolo_tf::l2Request* request, ::yolo_tf::l2Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void keras_regularizers_l2(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::l2Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void keras_regularizers_l2(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::l2Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // attribute getters
      virtual void attribute_tensor_shape(::grpc::ClientContext* context, const ::yolo_tf::TensorShapeRequest* request, ::yolo_tf::TensorShapeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void attribute_tensor_shape(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::TensorShapeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void attribute_tensor_shape(::grpc::ClientContext* context, const ::yolo_tf::TensorShapeRequest* request, ::yolo_tf::TensorShapeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void attribute_tensor_shape(::grpc::ClientContext* context, const ::yolo_tf::TensorShapeRequest* request, ::yolo_tf::TensorShapeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void attribute_tensor_shape(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::TensorShapeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void attribute_tensor_shape(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::TensorShapeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void attribute_model_load__weight(::grpc::ClientContext* context, const ::yolo_tf::LoadWeightsRequest* request, ::yolo_tf::LoadWeightsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void attribute_model_load__weight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::LoadWeightsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void attribute_model_load__weight(::grpc::ClientContext* context, const ::yolo_tf::LoadWeightsRequest* request, ::yolo_tf::LoadWeightsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void attribute_model_load__weight(::grpc::ClientContext* context, const ::yolo_tf::LoadWeightsRequest* request, ::yolo_tf::LoadWeightsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void attribute_model_load__weight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::LoadWeightsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void attribute_model_load__weight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::LoadWeightsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void attribute_checkpoint_expect__partial(::grpc::ClientContext* context, const ::yolo_tf::ExpectPartialRequest* request, ::yolo_tf::ExpectPartialResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void attribute_checkpoint_expect__partial(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ExpectPartialResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void attribute_checkpoint_expect__partial(::grpc::ClientContext* context, const ::yolo_tf::ExpectPartialRequest* request, ::yolo_tf::ExpectPartialResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void attribute_checkpoint_expect__partial(::grpc::ClientContext* context, const ::yolo_tf::ExpectPartialRequest* request, ::yolo_tf::ExpectPartialResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void attribute_checkpoint_expect__partial(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ExpectPartialResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void attribute_checkpoint_expect__partial(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ExpectPartialResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // tensor operations
      virtual void tensor_op_divide(::grpc::ClientContext* context, const ::yolo_tf::DivideRequest* request, ::yolo_tf::DivideResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void tensor_op_divide(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::DivideResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void tensor_op_divide(::grpc::ClientContext* context, const ::yolo_tf::DivideRequest* request, ::yolo_tf::DivideResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void tensor_op_divide(::grpc::ClientContext* context, const ::yolo_tf::DivideRequest* request, ::yolo_tf::DivideResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void tensor_op_divide(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::DivideResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void tensor_op_divide(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::DivideResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // common operations
      virtual void iterable_indexing(::grpc::ClientContext* context, const ::yolo_tf::IndexingRequest* request, ::yolo_tf::IndexingResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void iterable_indexing(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::IndexingResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void iterable_indexing(::grpc::ClientContext* context, const ::yolo_tf::IndexingRequest* request, ::yolo_tf::IndexingResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void iterable_indexing(::grpc::ClientContext* context, const ::yolo_tf::IndexingRequest* request, ::yolo_tf::IndexingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void iterable_indexing(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::IndexingResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void iterable_indexing(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::IndexingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void byte_tensor_to_numpy(::grpc::ClientContext* context, const ::yolo_tf::TensorToNumpyRequest* request, ::yolo_tf::TensorToNumPyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void byte_tensor_to_numpy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::TensorToNumPyResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void byte_tensor_to_numpy(::grpc::ClientContext* context, const ::yolo_tf::TensorToNumpyRequest* request, ::yolo_tf::TensorToNumPyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void byte_tensor_to_numpy(::grpc::ClientContext* context, const ::yolo_tf::TensorToNumpyRequest* request, ::yolo_tf::TensorToNumPyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void byte_tensor_to_numpy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::TensorToNumPyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void byte_tensor_to_numpy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::TensorToNumPyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void get_object_by_id(::grpc::ClientContext* context, const ::yolo_tf::GetObjectRequest* request, ::yolo_tf::GetObjectResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_object_by_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::GetObjectResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_object_by_id(::grpc::ClientContext* context, const ::yolo_tf::GetObjectRequest* request, ::yolo_tf::GetObjectResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_object_by_id(::grpc::ClientContext* context, const ::yolo_tf::GetObjectRequest* request, ::yolo_tf::GetObjectResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void get_object_by_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::GetObjectResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void get_object_by_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::GetObjectResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // YoloWrappers
      virtual void batch_normalization(::grpc::ClientContext* context, const ::yolo_tf::BatchNormRequest* request, ::yolo_tf::BatchNormResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void batch_normalization(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::BatchNormResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void batch_normalization(::grpc::ClientContext* context, const ::yolo_tf::BatchNormRequest* request, ::yolo_tf::BatchNormResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void batch_normalization(::grpc::ClientContext* context, const ::yolo_tf::BatchNormRequest* request, ::yolo_tf::BatchNormResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void batch_normalization(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::BatchNormResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void batch_normalization(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::BatchNormResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ConnectResponse>* AsyncConnectRaw(::grpc::ClientContext* context, const ::yolo_tf::ConnectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ConnectResponse>* PrepareAsyncConnectRaw(::grpc::ClientContext* context, const ::yolo_tf::ConnectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::DisconnectResponse>* AsyncDisconnectRaw(::grpc::ClientContext* context, const ::yolo_tf::DisconnectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::DisconnectResponse>* PrepareAsyncDisconnectRaw(::grpc::ClientContext* context, const ::yolo_tf::DisconnectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::HelloReply>* AsyncSayHelloRaw(::grpc::ClientContext* context, const ::yolo_tf::HelloRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::HelloReply>* PrepareAsyncSayHelloRaw(::grpc::ClientContext* context, const ::yolo_tf::HelloRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::CallResponse>* Asynccallable_emulatorRaw(::grpc::ClientContext* context, const ::yolo_tf::CallRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::CallResponse>* PrepareAsynccallable_emulatorRaw(::grpc::ClientContext* context, const ::yolo_tf::CallRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::SlicingResponse>* Asyncget_iterable_slicingRaw(::grpc::ClientContext* context, const ::yolo_tf::SlicingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::SlicingResponse>* PrepareAsyncget_iterable_slicingRaw(::grpc::ClientContext* context, const ::yolo_tf::SlicingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ConstantResponse>* AsyncconstantRaw(::grpc::ClientContext* context, const ::yolo_tf::ConstantRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ConstantResponse>* PrepareAsyncconstantRaw(::grpc::ClientContext* context, const ::yolo_tf::ConstantRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::PhysicalDevices>* Asyncconfig_experimental_list__physical__devicesRaw(::grpc::ClientContext* context, const ::yolo_tf::DeviceType& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::PhysicalDevices>* PrepareAsyncconfig_experimental_list__physical__devicesRaw(::grpc::ClientContext* context, const ::yolo_tf::DeviceType& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::DecodeImageResponse>* Asyncimage_decode__imageRaw(::grpc::ClientContext* context, const ::yolo_tf::DecodeImageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::DecodeImageResponse>* PrepareAsyncimage_decode__imageRaw(::grpc::ClientContext* context, const ::yolo_tf::DecodeImageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ExpandDemensionResponse>* Asyncexpand__dimsRaw(::grpc::ClientContext* context, const ::yolo_tf::ExpandDemensionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ExpandDemensionResponse>* PrepareAsyncexpand__dimsRaw(::grpc::ClientContext* context, const ::yolo_tf::ExpandDemensionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::InputResponse>* Asynckeras_layers_InputRaw(::grpc::ClientContext* context, const ::yolo_tf::InputRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::InputResponse>* PrepareAsynckeras_layers_InputRaw(::grpc::ClientContext* context, const ::yolo_tf::InputRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ModelResponse>* Asynckeras_ModelRaw(::grpc::ClientContext* context, const ::yolo_tf::ModelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ModelResponse>* PrepareAsynckeras_ModelRaw(::grpc::ClientContext* context, const ::yolo_tf::ModelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ZeroPadding2DResponse>* Asynckeras_layers_ZeroPadding2DRaw(::grpc::ClientContext* context, const ::yolo_tf::ZeroPadding2DRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ZeroPadding2DResponse>* PrepareAsynckeras_layers_ZeroPadding2DRaw(::grpc::ClientContext* context, const ::yolo_tf::ZeroPadding2DRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::Conv2DResponse>* Asynckeras_layers_Conv2DRaw(::grpc::ClientContext* context, const ::yolo_tf::Conv2DRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::Conv2DResponse>* PrepareAsynckeras_layers_Conv2DRaw(::grpc::ClientContext* context, const ::yolo_tf::Conv2DRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::LeakyReluResponse>* Asynckeras_layers_LeakyReLURaw(::grpc::ClientContext* context, const ::yolo_tf::LeakyReluRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::LeakyReluResponse>* PrepareAsynckeras_layers_LeakyReLURaw(::grpc::ClientContext* context, const ::yolo_tf::LeakyReluRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::AddResponse>* Asynckeras_layers_AddRaw(::grpc::ClientContext* context, const ::yolo_tf::AddRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::AddResponse>* PrepareAsynckeras_layers_AddRaw(::grpc::ClientContext* context, const ::yolo_tf::AddRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::LambdaResponse>* Asynckeras_layers_LambdaRaw(::grpc::ClientContext* context, const ::yolo_tf::LambdaRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::LambdaResponse>* PrepareAsynckeras_layers_LambdaRaw(::grpc::ClientContext* context, const ::yolo_tf::LambdaRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::UpSampling2DResponse>* Asynckeras_layers_UpSampling2DRaw(::grpc::ClientContext* context, const ::yolo_tf::UpSampling2DRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::UpSampling2DResponse>* PrepareAsynckeras_layers_UpSampling2DRaw(::grpc::ClientContext* context, const ::yolo_tf::UpSampling2DRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ContcatenateResponse>* Asynckeras_layers_ConcatenateRaw(::grpc::ClientContext* context, const ::yolo_tf::ConcatenateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ContcatenateResponse>* PrepareAsynckeras_layers_ConcatenateRaw(::grpc::ClientContext* context, const ::yolo_tf::ConcatenateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ImageResizeResponse>* Asyncimage_resizeRaw(::grpc::ClientContext* context, const ::yolo_tf::ImageResizeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ImageResizeResponse>* PrepareAsyncimage_resizeRaw(::grpc::ClientContext* context, const ::yolo_tf::ImageResizeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::l2Response>* Asynckeras_regularizers_l2Raw(::grpc::ClientContext* context, const ::yolo_tf::l2Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::l2Response>* PrepareAsynckeras_regularizers_l2Raw(::grpc::ClientContext* context, const ::yolo_tf::l2Request& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::TensorShapeResponse>* Asyncattribute_tensor_shapeRaw(::grpc::ClientContext* context, const ::yolo_tf::TensorShapeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::TensorShapeResponse>* PrepareAsyncattribute_tensor_shapeRaw(::grpc::ClientContext* context, const ::yolo_tf::TensorShapeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::LoadWeightsResponse>* Asyncattribute_model_load__weightRaw(::grpc::ClientContext* context, const ::yolo_tf::LoadWeightsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::LoadWeightsResponse>* PrepareAsyncattribute_model_load__weightRaw(::grpc::ClientContext* context, const ::yolo_tf::LoadWeightsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ExpectPartialResponse>* Asyncattribute_checkpoint_expect__partialRaw(::grpc::ClientContext* context, const ::yolo_tf::ExpectPartialRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::ExpectPartialResponse>* PrepareAsyncattribute_checkpoint_expect__partialRaw(::grpc::ClientContext* context, const ::yolo_tf::ExpectPartialRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::DivideResponse>* Asynctensor_op_divideRaw(::grpc::ClientContext* context, const ::yolo_tf::DivideRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::DivideResponse>* PrepareAsynctensor_op_divideRaw(::grpc::ClientContext* context, const ::yolo_tf::DivideRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::IndexingResponse>* Asynciterable_indexingRaw(::grpc::ClientContext* context, const ::yolo_tf::IndexingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::IndexingResponse>* PrepareAsynciterable_indexingRaw(::grpc::ClientContext* context, const ::yolo_tf::IndexingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::TensorToNumPyResponse>* Asyncbyte_tensor_to_numpyRaw(::grpc::ClientContext* context, const ::yolo_tf::TensorToNumpyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::TensorToNumPyResponse>* PrepareAsyncbyte_tensor_to_numpyRaw(::grpc::ClientContext* context, const ::yolo_tf::TensorToNumpyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::GetObjectResponse>* Asyncget_object_by_idRaw(::grpc::ClientContext* context, const ::yolo_tf::GetObjectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::GetObjectResponse>* PrepareAsyncget_object_by_idRaw(::grpc::ClientContext* context, const ::yolo_tf::GetObjectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::BatchNormResponse>* Asyncbatch_normalizationRaw(::grpc::ClientContext* context, const ::yolo_tf::BatchNormRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::yolo_tf::BatchNormResponse>* PrepareAsyncbatch_normalizationRaw(::grpc::ClientContext* context, const ::yolo_tf::BatchNormRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status Connect(::grpc::ClientContext* context, const ::yolo_tf::ConnectRequest& request, ::yolo_tf::ConnectResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ConnectResponse>> AsyncConnect(::grpc::ClientContext* context, const ::yolo_tf::ConnectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ConnectResponse>>(AsyncConnectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ConnectResponse>> PrepareAsyncConnect(::grpc::ClientContext* context, const ::yolo_tf::ConnectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ConnectResponse>>(PrepareAsyncConnectRaw(context, request, cq));
    }
    ::grpc::Status Disconnect(::grpc::ClientContext* context, const ::yolo_tf::DisconnectRequest& request, ::yolo_tf::DisconnectResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::DisconnectResponse>> AsyncDisconnect(::grpc::ClientContext* context, const ::yolo_tf::DisconnectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::DisconnectResponse>>(AsyncDisconnectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::DisconnectResponse>> PrepareAsyncDisconnect(::grpc::ClientContext* context, const ::yolo_tf::DisconnectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::DisconnectResponse>>(PrepareAsyncDisconnectRaw(context, request, cq));
    }
    ::grpc::Status SayHello(::grpc::ClientContext* context, const ::yolo_tf::HelloRequest& request, ::yolo_tf::HelloReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::HelloReply>> AsyncSayHello(::grpc::ClientContext* context, const ::yolo_tf::HelloRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::HelloReply>>(AsyncSayHelloRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::HelloReply>> PrepareAsyncSayHello(::grpc::ClientContext* context, const ::yolo_tf::HelloRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::HelloReply>>(PrepareAsyncSayHelloRaw(context, request, cq));
    }
    ::grpc::Status callable_emulator(::grpc::ClientContext* context, const ::yolo_tf::CallRequest& request, ::yolo_tf::CallResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::CallResponse>> Asynccallable_emulator(::grpc::ClientContext* context, const ::yolo_tf::CallRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::CallResponse>>(Asynccallable_emulatorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::CallResponse>> PrepareAsynccallable_emulator(::grpc::ClientContext* context, const ::yolo_tf::CallRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::CallResponse>>(PrepareAsynccallable_emulatorRaw(context, request, cq));
    }
    ::grpc::Status get_iterable_slicing(::grpc::ClientContext* context, const ::yolo_tf::SlicingRequest& request, ::yolo_tf::SlicingResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::SlicingResponse>> Asyncget_iterable_slicing(::grpc::ClientContext* context, const ::yolo_tf::SlicingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::SlicingResponse>>(Asyncget_iterable_slicingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::SlicingResponse>> PrepareAsyncget_iterable_slicing(::grpc::ClientContext* context, const ::yolo_tf::SlicingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::SlicingResponse>>(PrepareAsyncget_iterable_slicingRaw(context, request, cq));
    }
    ::grpc::Status constant(::grpc::ClientContext* context, const ::yolo_tf::ConstantRequest& request, ::yolo_tf::ConstantResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ConstantResponse>> Asyncconstant(::grpc::ClientContext* context, const ::yolo_tf::ConstantRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ConstantResponse>>(AsyncconstantRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ConstantResponse>> PrepareAsyncconstant(::grpc::ClientContext* context, const ::yolo_tf::ConstantRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ConstantResponse>>(PrepareAsyncconstantRaw(context, request, cq));
    }
    ::grpc::Status config_experimental_list__physical__devices(::grpc::ClientContext* context, const ::yolo_tf::DeviceType& request, ::yolo_tf::PhysicalDevices* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::PhysicalDevices>> Asyncconfig_experimental_list__physical__devices(::grpc::ClientContext* context, const ::yolo_tf::DeviceType& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::PhysicalDevices>>(Asyncconfig_experimental_list__physical__devicesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::PhysicalDevices>> PrepareAsyncconfig_experimental_list__physical__devices(::grpc::ClientContext* context, const ::yolo_tf::DeviceType& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::PhysicalDevices>>(PrepareAsyncconfig_experimental_list__physical__devicesRaw(context, request, cq));
    }
    ::grpc::Status image_decode__image(::grpc::ClientContext* context, const ::yolo_tf::DecodeImageRequest& request, ::yolo_tf::DecodeImageResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::DecodeImageResponse>> Asyncimage_decode__image(::grpc::ClientContext* context, const ::yolo_tf::DecodeImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::DecodeImageResponse>>(Asyncimage_decode__imageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::DecodeImageResponse>> PrepareAsyncimage_decode__image(::grpc::ClientContext* context, const ::yolo_tf::DecodeImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::DecodeImageResponse>>(PrepareAsyncimage_decode__imageRaw(context, request, cq));
    }
    ::grpc::Status expand__dims(::grpc::ClientContext* context, const ::yolo_tf::ExpandDemensionRequest& request, ::yolo_tf::ExpandDemensionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ExpandDemensionResponse>> Asyncexpand__dims(::grpc::ClientContext* context, const ::yolo_tf::ExpandDemensionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ExpandDemensionResponse>>(Asyncexpand__dimsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ExpandDemensionResponse>> PrepareAsyncexpand__dims(::grpc::ClientContext* context, const ::yolo_tf::ExpandDemensionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ExpandDemensionResponse>>(PrepareAsyncexpand__dimsRaw(context, request, cq));
    }
    ::grpc::Status keras_layers_Input(::grpc::ClientContext* context, const ::yolo_tf::InputRequest& request, ::yolo_tf::InputResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::InputResponse>> Asynckeras_layers_Input(::grpc::ClientContext* context, const ::yolo_tf::InputRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::InputResponse>>(Asynckeras_layers_InputRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::InputResponse>> PrepareAsynckeras_layers_Input(::grpc::ClientContext* context, const ::yolo_tf::InputRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::InputResponse>>(PrepareAsynckeras_layers_InputRaw(context, request, cq));
    }
    ::grpc::Status keras_Model(::grpc::ClientContext* context, const ::yolo_tf::ModelRequest& request, ::yolo_tf::ModelResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ModelResponse>> Asynckeras_Model(::grpc::ClientContext* context, const ::yolo_tf::ModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ModelResponse>>(Asynckeras_ModelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ModelResponse>> PrepareAsynckeras_Model(::grpc::ClientContext* context, const ::yolo_tf::ModelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ModelResponse>>(PrepareAsynckeras_ModelRaw(context, request, cq));
    }
    ::grpc::Status keras_layers_ZeroPadding2D(::grpc::ClientContext* context, const ::yolo_tf::ZeroPadding2DRequest& request, ::yolo_tf::ZeroPadding2DResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ZeroPadding2DResponse>> Asynckeras_layers_ZeroPadding2D(::grpc::ClientContext* context, const ::yolo_tf::ZeroPadding2DRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ZeroPadding2DResponse>>(Asynckeras_layers_ZeroPadding2DRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ZeroPadding2DResponse>> PrepareAsynckeras_layers_ZeroPadding2D(::grpc::ClientContext* context, const ::yolo_tf::ZeroPadding2DRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ZeroPadding2DResponse>>(PrepareAsynckeras_layers_ZeroPadding2DRaw(context, request, cq));
    }
    ::grpc::Status keras_layers_Conv2D(::grpc::ClientContext* context, const ::yolo_tf::Conv2DRequest& request, ::yolo_tf::Conv2DResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::Conv2DResponse>> Asynckeras_layers_Conv2D(::grpc::ClientContext* context, const ::yolo_tf::Conv2DRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::Conv2DResponse>>(Asynckeras_layers_Conv2DRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::Conv2DResponse>> PrepareAsynckeras_layers_Conv2D(::grpc::ClientContext* context, const ::yolo_tf::Conv2DRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::Conv2DResponse>>(PrepareAsynckeras_layers_Conv2DRaw(context, request, cq));
    }
    ::grpc::Status keras_layers_LeakyReLU(::grpc::ClientContext* context, const ::yolo_tf::LeakyReluRequest& request, ::yolo_tf::LeakyReluResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::LeakyReluResponse>> Asynckeras_layers_LeakyReLU(::grpc::ClientContext* context, const ::yolo_tf::LeakyReluRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::LeakyReluResponse>>(Asynckeras_layers_LeakyReLURaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::LeakyReluResponse>> PrepareAsynckeras_layers_LeakyReLU(::grpc::ClientContext* context, const ::yolo_tf::LeakyReluRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::LeakyReluResponse>>(PrepareAsynckeras_layers_LeakyReLURaw(context, request, cq));
    }
    ::grpc::Status keras_layers_Add(::grpc::ClientContext* context, const ::yolo_tf::AddRequest& request, ::yolo_tf::AddResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::AddResponse>> Asynckeras_layers_Add(::grpc::ClientContext* context, const ::yolo_tf::AddRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::AddResponse>>(Asynckeras_layers_AddRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::AddResponse>> PrepareAsynckeras_layers_Add(::grpc::ClientContext* context, const ::yolo_tf::AddRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::AddResponse>>(PrepareAsynckeras_layers_AddRaw(context, request, cq));
    }
    ::grpc::Status keras_layers_Lambda(::grpc::ClientContext* context, const ::yolo_tf::LambdaRequest& request, ::yolo_tf::LambdaResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::LambdaResponse>> Asynckeras_layers_Lambda(::grpc::ClientContext* context, const ::yolo_tf::LambdaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::LambdaResponse>>(Asynckeras_layers_LambdaRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::LambdaResponse>> PrepareAsynckeras_layers_Lambda(::grpc::ClientContext* context, const ::yolo_tf::LambdaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::LambdaResponse>>(PrepareAsynckeras_layers_LambdaRaw(context, request, cq));
    }
    ::grpc::Status keras_layers_UpSampling2D(::grpc::ClientContext* context, const ::yolo_tf::UpSampling2DRequest& request, ::yolo_tf::UpSampling2DResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::UpSampling2DResponse>> Asynckeras_layers_UpSampling2D(::grpc::ClientContext* context, const ::yolo_tf::UpSampling2DRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::UpSampling2DResponse>>(Asynckeras_layers_UpSampling2DRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::UpSampling2DResponse>> PrepareAsynckeras_layers_UpSampling2D(::grpc::ClientContext* context, const ::yolo_tf::UpSampling2DRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::UpSampling2DResponse>>(PrepareAsynckeras_layers_UpSampling2DRaw(context, request, cq));
    }
    ::grpc::Status keras_layers_Concatenate(::grpc::ClientContext* context, const ::yolo_tf::ConcatenateRequest& request, ::yolo_tf::ContcatenateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ContcatenateResponse>> Asynckeras_layers_Concatenate(::grpc::ClientContext* context, const ::yolo_tf::ConcatenateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ContcatenateResponse>>(Asynckeras_layers_ConcatenateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ContcatenateResponse>> PrepareAsynckeras_layers_Concatenate(::grpc::ClientContext* context, const ::yolo_tf::ConcatenateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ContcatenateResponse>>(PrepareAsynckeras_layers_ConcatenateRaw(context, request, cq));
    }
    ::grpc::Status image_resize(::grpc::ClientContext* context, const ::yolo_tf::ImageResizeRequest& request, ::yolo_tf::ImageResizeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ImageResizeResponse>> Asyncimage_resize(::grpc::ClientContext* context, const ::yolo_tf::ImageResizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ImageResizeResponse>>(Asyncimage_resizeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ImageResizeResponse>> PrepareAsyncimage_resize(::grpc::ClientContext* context, const ::yolo_tf::ImageResizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ImageResizeResponse>>(PrepareAsyncimage_resizeRaw(context, request, cq));
    }
    ::grpc::Status keras_regularizers_l2(::grpc::ClientContext* context, const ::yolo_tf::l2Request& request, ::yolo_tf::l2Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::l2Response>> Asynckeras_regularizers_l2(::grpc::ClientContext* context, const ::yolo_tf::l2Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::l2Response>>(Asynckeras_regularizers_l2Raw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::l2Response>> PrepareAsynckeras_regularizers_l2(::grpc::ClientContext* context, const ::yolo_tf::l2Request& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::l2Response>>(PrepareAsynckeras_regularizers_l2Raw(context, request, cq));
    }
    ::grpc::Status attribute_tensor_shape(::grpc::ClientContext* context, const ::yolo_tf::TensorShapeRequest& request, ::yolo_tf::TensorShapeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::TensorShapeResponse>> Asyncattribute_tensor_shape(::grpc::ClientContext* context, const ::yolo_tf::TensorShapeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::TensorShapeResponse>>(Asyncattribute_tensor_shapeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::TensorShapeResponse>> PrepareAsyncattribute_tensor_shape(::grpc::ClientContext* context, const ::yolo_tf::TensorShapeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::TensorShapeResponse>>(PrepareAsyncattribute_tensor_shapeRaw(context, request, cq));
    }
    ::grpc::Status attribute_model_load__weight(::grpc::ClientContext* context, const ::yolo_tf::LoadWeightsRequest& request, ::yolo_tf::LoadWeightsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::LoadWeightsResponse>> Asyncattribute_model_load__weight(::grpc::ClientContext* context, const ::yolo_tf::LoadWeightsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::LoadWeightsResponse>>(Asyncattribute_model_load__weightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::LoadWeightsResponse>> PrepareAsyncattribute_model_load__weight(::grpc::ClientContext* context, const ::yolo_tf::LoadWeightsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::LoadWeightsResponse>>(PrepareAsyncattribute_model_load__weightRaw(context, request, cq));
    }
    ::grpc::Status attribute_checkpoint_expect__partial(::grpc::ClientContext* context, const ::yolo_tf::ExpectPartialRequest& request, ::yolo_tf::ExpectPartialResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ExpectPartialResponse>> Asyncattribute_checkpoint_expect__partial(::grpc::ClientContext* context, const ::yolo_tf::ExpectPartialRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ExpectPartialResponse>>(Asyncattribute_checkpoint_expect__partialRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ExpectPartialResponse>> PrepareAsyncattribute_checkpoint_expect__partial(::grpc::ClientContext* context, const ::yolo_tf::ExpectPartialRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::ExpectPartialResponse>>(PrepareAsyncattribute_checkpoint_expect__partialRaw(context, request, cq));
    }
    ::grpc::Status tensor_op_divide(::grpc::ClientContext* context, const ::yolo_tf::DivideRequest& request, ::yolo_tf::DivideResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::DivideResponse>> Asynctensor_op_divide(::grpc::ClientContext* context, const ::yolo_tf::DivideRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::DivideResponse>>(Asynctensor_op_divideRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::DivideResponse>> PrepareAsynctensor_op_divide(::grpc::ClientContext* context, const ::yolo_tf::DivideRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::DivideResponse>>(PrepareAsynctensor_op_divideRaw(context, request, cq));
    }
    ::grpc::Status iterable_indexing(::grpc::ClientContext* context, const ::yolo_tf::IndexingRequest& request, ::yolo_tf::IndexingResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::IndexingResponse>> Asynciterable_indexing(::grpc::ClientContext* context, const ::yolo_tf::IndexingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::IndexingResponse>>(Asynciterable_indexingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::IndexingResponse>> PrepareAsynciterable_indexing(::grpc::ClientContext* context, const ::yolo_tf::IndexingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::IndexingResponse>>(PrepareAsynciterable_indexingRaw(context, request, cq));
    }
    ::grpc::Status byte_tensor_to_numpy(::grpc::ClientContext* context, const ::yolo_tf::TensorToNumpyRequest& request, ::yolo_tf::TensorToNumPyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::TensorToNumPyResponse>> Asyncbyte_tensor_to_numpy(::grpc::ClientContext* context, const ::yolo_tf::TensorToNumpyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::TensorToNumPyResponse>>(Asyncbyte_tensor_to_numpyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::TensorToNumPyResponse>> PrepareAsyncbyte_tensor_to_numpy(::grpc::ClientContext* context, const ::yolo_tf::TensorToNumpyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::TensorToNumPyResponse>>(PrepareAsyncbyte_tensor_to_numpyRaw(context, request, cq));
    }
    ::grpc::Status get_object_by_id(::grpc::ClientContext* context, const ::yolo_tf::GetObjectRequest& request, ::yolo_tf::GetObjectResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::GetObjectResponse>> Asyncget_object_by_id(::grpc::ClientContext* context, const ::yolo_tf::GetObjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::GetObjectResponse>>(Asyncget_object_by_idRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::GetObjectResponse>> PrepareAsyncget_object_by_id(::grpc::ClientContext* context, const ::yolo_tf::GetObjectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::GetObjectResponse>>(PrepareAsyncget_object_by_idRaw(context, request, cq));
    }
    ::grpc::Status batch_normalization(::grpc::ClientContext* context, const ::yolo_tf::BatchNormRequest& request, ::yolo_tf::BatchNormResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::BatchNormResponse>> Asyncbatch_normalization(::grpc::ClientContext* context, const ::yolo_tf::BatchNormRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::BatchNormResponse>>(Asyncbatch_normalizationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::BatchNormResponse>> PrepareAsyncbatch_normalization(::grpc::ClientContext* context, const ::yolo_tf::BatchNormRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::yolo_tf::BatchNormResponse>>(PrepareAsyncbatch_normalizationRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void Connect(::grpc::ClientContext* context, const ::yolo_tf::ConnectRequest* request, ::yolo_tf::ConnectResponse* response, std::function<void(::grpc::Status)>) override;
      void Connect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ConnectResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Connect(::grpc::ClientContext* context, const ::yolo_tf::ConnectRequest* request, ::yolo_tf::ConnectResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Connect(::grpc::ClientContext* context, const ::yolo_tf::ConnectRequest* request, ::yolo_tf::ConnectResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Connect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ConnectResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Connect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ConnectResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Disconnect(::grpc::ClientContext* context, const ::yolo_tf::DisconnectRequest* request, ::yolo_tf::DisconnectResponse* response, std::function<void(::grpc::Status)>) override;
      void Disconnect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::DisconnectResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Disconnect(::grpc::ClientContext* context, const ::yolo_tf::DisconnectRequest* request, ::yolo_tf::DisconnectResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Disconnect(::grpc::ClientContext* context, const ::yolo_tf::DisconnectRequest* request, ::yolo_tf::DisconnectResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Disconnect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::DisconnectResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Disconnect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::DisconnectResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SayHello(::grpc::ClientContext* context, const ::yolo_tf::HelloRequest* request, ::yolo_tf::HelloReply* response, std::function<void(::grpc::Status)>) override;
      void SayHello(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::HelloReply* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SayHello(::grpc::ClientContext* context, const ::yolo_tf::HelloRequest* request, ::yolo_tf::HelloReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SayHello(::grpc::ClientContext* context, const ::yolo_tf::HelloRequest* request, ::yolo_tf::HelloReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SayHello(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::HelloReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SayHello(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::HelloReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void callable_emulator(::grpc::ClientContext* context, const ::yolo_tf::CallRequest* request, ::yolo_tf::CallResponse* response, std::function<void(::grpc::Status)>) override;
      void callable_emulator(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::CallResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void callable_emulator(::grpc::ClientContext* context, const ::yolo_tf::CallRequest* request, ::yolo_tf::CallResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void callable_emulator(::grpc::ClientContext* context, const ::yolo_tf::CallRequest* request, ::yolo_tf::CallResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void callable_emulator(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::CallResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void callable_emulator(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::CallResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void get_iterable_slicing(::grpc::ClientContext* context, const ::yolo_tf::SlicingRequest* request, ::yolo_tf::SlicingResponse* response, std::function<void(::grpc::Status)>) override;
      void get_iterable_slicing(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::SlicingResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_iterable_slicing(::grpc::ClientContext* context, const ::yolo_tf::SlicingRequest* request, ::yolo_tf::SlicingResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_iterable_slicing(::grpc::ClientContext* context, const ::yolo_tf::SlicingRequest* request, ::yolo_tf::SlicingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_iterable_slicing(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::SlicingResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_iterable_slicing(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::SlicingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void constant(::grpc::ClientContext* context, const ::yolo_tf::ConstantRequest* request, ::yolo_tf::ConstantResponse* response, std::function<void(::grpc::Status)>) override;
      void constant(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ConstantResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void constant(::grpc::ClientContext* context, const ::yolo_tf::ConstantRequest* request, ::yolo_tf::ConstantResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void constant(::grpc::ClientContext* context, const ::yolo_tf::ConstantRequest* request, ::yolo_tf::ConstantResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void constant(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ConstantResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void constant(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ConstantResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void config_experimental_list__physical__devices(::grpc::ClientContext* context, const ::yolo_tf::DeviceType* request, ::yolo_tf::PhysicalDevices* response, std::function<void(::grpc::Status)>) override;
      void config_experimental_list__physical__devices(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::PhysicalDevices* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void config_experimental_list__physical__devices(::grpc::ClientContext* context, const ::yolo_tf::DeviceType* request, ::yolo_tf::PhysicalDevices* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void config_experimental_list__physical__devices(::grpc::ClientContext* context, const ::yolo_tf::DeviceType* request, ::yolo_tf::PhysicalDevices* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void config_experimental_list__physical__devices(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::PhysicalDevices* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void config_experimental_list__physical__devices(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::PhysicalDevices* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void image_decode__image(::grpc::ClientContext* context, const ::yolo_tf::DecodeImageRequest* request, ::yolo_tf::DecodeImageResponse* response, std::function<void(::grpc::Status)>) override;
      void image_decode__image(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::DecodeImageResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void image_decode__image(::grpc::ClientContext* context, const ::yolo_tf::DecodeImageRequest* request, ::yolo_tf::DecodeImageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void image_decode__image(::grpc::ClientContext* context, const ::yolo_tf::DecodeImageRequest* request, ::yolo_tf::DecodeImageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void image_decode__image(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::DecodeImageResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void image_decode__image(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::DecodeImageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void expand__dims(::grpc::ClientContext* context, const ::yolo_tf::ExpandDemensionRequest* request, ::yolo_tf::ExpandDemensionResponse* response, std::function<void(::grpc::Status)>) override;
      void expand__dims(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ExpandDemensionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void expand__dims(::grpc::ClientContext* context, const ::yolo_tf::ExpandDemensionRequest* request, ::yolo_tf::ExpandDemensionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void expand__dims(::grpc::ClientContext* context, const ::yolo_tf::ExpandDemensionRequest* request, ::yolo_tf::ExpandDemensionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void expand__dims(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ExpandDemensionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void expand__dims(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ExpandDemensionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void keras_layers_Input(::grpc::ClientContext* context, const ::yolo_tf::InputRequest* request, ::yolo_tf::InputResponse* response, std::function<void(::grpc::Status)>) override;
      void keras_layers_Input(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::InputResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void keras_layers_Input(::grpc::ClientContext* context, const ::yolo_tf::InputRequest* request, ::yolo_tf::InputResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void keras_layers_Input(::grpc::ClientContext* context, const ::yolo_tf::InputRequest* request, ::yolo_tf::InputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void keras_layers_Input(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::InputResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void keras_layers_Input(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::InputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void keras_Model(::grpc::ClientContext* context, const ::yolo_tf::ModelRequest* request, ::yolo_tf::ModelResponse* response, std::function<void(::grpc::Status)>) override;
      void keras_Model(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ModelResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void keras_Model(::grpc::ClientContext* context, const ::yolo_tf::ModelRequest* request, ::yolo_tf::ModelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void keras_Model(::grpc::ClientContext* context, const ::yolo_tf::ModelRequest* request, ::yolo_tf::ModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void keras_Model(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ModelResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void keras_Model(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void keras_layers_ZeroPadding2D(::grpc::ClientContext* context, const ::yolo_tf::ZeroPadding2DRequest* request, ::yolo_tf::ZeroPadding2DResponse* response, std::function<void(::grpc::Status)>) override;
      void keras_layers_ZeroPadding2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ZeroPadding2DResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void keras_layers_ZeroPadding2D(::grpc::ClientContext* context, const ::yolo_tf::ZeroPadding2DRequest* request, ::yolo_tf::ZeroPadding2DResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void keras_layers_ZeroPadding2D(::grpc::ClientContext* context, const ::yolo_tf::ZeroPadding2DRequest* request, ::yolo_tf::ZeroPadding2DResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void keras_layers_ZeroPadding2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ZeroPadding2DResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void keras_layers_ZeroPadding2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ZeroPadding2DResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void keras_layers_Conv2D(::grpc::ClientContext* context, const ::yolo_tf::Conv2DRequest* request, ::yolo_tf::Conv2DResponse* response, std::function<void(::grpc::Status)>) override;
      void keras_layers_Conv2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::Conv2DResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void keras_layers_Conv2D(::grpc::ClientContext* context, const ::yolo_tf::Conv2DRequest* request, ::yolo_tf::Conv2DResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void keras_layers_Conv2D(::grpc::ClientContext* context, const ::yolo_tf::Conv2DRequest* request, ::yolo_tf::Conv2DResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void keras_layers_Conv2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::Conv2DResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void keras_layers_Conv2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::Conv2DResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void keras_layers_LeakyReLU(::grpc::ClientContext* context, const ::yolo_tf::LeakyReluRequest* request, ::yolo_tf::LeakyReluResponse* response, std::function<void(::grpc::Status)>) override;
      void keras_layers_LeakyReLU(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::LeakyReluResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void keras_layers_LeakyReLU(::grpc::ClientContext* context, const ::yolo_tf::LeakyReluRequest* request, ::yolo_tf::LeakyReluResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void keras_layers_LeakyReLU(::grpc::ClientContext* context, const ::yolo_tf::LeakyReluRequest* request, ::yolo_tf::LeakyReluResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void keras_layers_LeakyReLU(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::LeakyReluResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void keras_layers_LeakyReLU(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::LeakyReluResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void keras_layers_Add(::grpc::ClientContext* context, const ::yolo_tf::AddRequest* request, ::yolo_tf::AddResponse* response, std::function<void(::grpc::Status)>) override;
      void keras_layers_Add(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::AddResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void keras_layers_Add(::grpc::ClientContext* context, const ::yolo_tf::AddRequest* request, ::yolo_tf::AddResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void keras_layers_Add(::grpc::ClientContext* context, const ::yolo_tf::AddRequest* request, ::yolo_tf::AddResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void keras_layers_Add(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::AddResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void keras_layers_Add(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::AddResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void keras_layers_Lambda(::grpc::ClientContext* context, const ::yolo_tf::LambdaRequest* request, ::yolo_tf::LambdaResponse* response, std::function<void(::grpc::Status)>) override;
      void keras_layers_Lambda(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::LambdaResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void keras_layers_Lambda(::grpc::ClientContext* context, const ::yolo_tf::LambdaRequest* request, ::yolo_tf::LambdaResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void keras_layers_Lambda(::grpc::ClientContext* context, const ::yolo_tf::LambdaRequest* request, ::yolo_tf::LambdaResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void keras_layers_Lambda(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::LambdaResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void keras_layers_Lambda(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::LambdaResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void keras_layers_UpSampling2D(::grpc::ClientContext* context, const ::yolo_tf::UpSampling2DRequest* request, ::yolo_tf::UpSampling2DResponse* response, std::function<void(::grpc::Status)>) override;
      void keras_layers_UpSampling2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::UpSampling2DResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void keras_layers_UpSampling2D(::grpc::ClientContext* context, const ::yolo_tf::UpSampling2DRequest* request, ::yolo_tf::UpSampling2DResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void keras_layers_UpSampling2D(::grpc::ClientContext* context, const ::yolo_tf::UpSampling2DRequest* request, ::yolo_tf::UpSampling2DResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void keras_layers_UpSampling2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::UpSampling2DResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void keras_layers_UpSampling2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::UpSampling2DResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void keras_layers_Concatenate(::grpc::ClientContext* context, const ::yolo_tf::ConcatenateRequest* request, ::yolo_tf::ContcatenateResponse* response, std::function<void(::grpc::Status)>) override;
      void keras_layers_Concatenate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ContcatenateResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void keras_layers_Concatenate(::grpc::ClientContext* context, const ::yolo_tf::ConcatenateRequest* request, ::yolo_tf::ContcatenateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void keras_layers_Concatenate(::grpc::ClientContext* context, const ::yolo_tf::ConcatenateRequest* request, ::yolo_tf::ContcatenateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void keras_layers_Concatenate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ContcatenateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void keras_layers_Concatenate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ContcatenateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void image_resize(::grpc::ClientContext* context, const ::yolo_tf::ImageResizeRequest* request, ::yolo_tf::ImageResizeResponse* response, std::function<void(::grpc::Status)>) override;
      void image_resize(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ImageResizeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void image_resize(::grpc::ClientContext* context, const ::yolo_tf::ImageResizeRequest* request, ::yolo_tf::ImageResizeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void image_resize(::grpc::ClientContext* context, const ::yolo_tf::ImageResizeRequest* request, ::yolo_tf::ImageResizeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void image_resize(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ImageResizeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void image_resize(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ImageResizeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void keras_regularizers_l2(::grpc::ClientContext* context, const ::yolo_tf::l2Request* request, ::yolo_tf::l2Response* response, std::function<void(::grpc::Status)>) override;
      void keras_regularizers_l2(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::l2Response* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void keras_regularizers_l2(::grpc::ClientContext* context, const ::yolo_tf::l2Request* request, ::yolo_tf::l2Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void keras_regularizers_l2(::grpc::ClientContext* context, const ::yolo_tf::l2Request* request, ::yolo_tf::l2Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void keras_regularizers_l2(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::l2Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void keras_regularizers_l2(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::l2Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void attribute_tensor_shape(::grpc::ClientContext* context, const ::yolo_tf::TensorShapeRequest* request, ::yolo_tf::TensorShapeResponse* response, std::function<void(::grpc::Status)>) override;
      void attribute_tensor_shape(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::TensorShapeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void attribute_tensor_shape(::grpc::ClientContext* context, const ::yolo_tf::TensorShapeRequest* request, ::yolo_tf::TensorShapeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void attribute_tensor_shape(::grpc::ClientContext* context, const ::yolo_tf::TensorShapeRequest* request, ::yolo_tf::TensorShapeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void attribute_tensor_shape(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::TensorShapeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void attribute_tensor_shape(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::TensorShapeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void attribute_model_load__weight(::grpc::ClientContext* context, const ::yolo_tf::LoadWeightsRequest* request, ::yolo_tf::LoadWeightsResponse* response, std::function<void(::grpc::Status)>) override;
      void attribute_model_load__weight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::LoadWeightsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void attribute_model_load__weight(::grpc::ClientContext* context, const ::yolo_tf::LoadWeightsRequest* request, ::yolo_tf::LoadWeightsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void attribute_model_load__weight(::grpc::ClientContext* context, const ::yolo_tf::LoadWeightsRequest* request, ::yolo_tf::LoadWeightsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void attribute_model_load__weight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::LoadWeightsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void attribute_model_load__weight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::LoadWeightsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void attribute_checkpoint_expect__partial(::grpc::ClientContext* context, const ::yolo_tf::ExpectPartialRequest* request, ::yolo_tf::ExpectPartialResponse* response, std::function<void(::grpc::Status)>) override;
      void attribute_checkpoint_expect__partial(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ExpectPartialResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void attribute_checkpoint_expect__partial(::grpc::ClientContext* context, const ::yolo_tf::ExpectPartialRequest* request, ::yolo_tf::ExpectPartialResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void attribute_checkpoint_expect__partial(::grpc::ClientContext* context, const ::yolo_tf::ExpectPartialRequest* request, ::yolo_tf::ExpectPartialResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void attribute_checkpoint_expect__partial(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ExpectPartialResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void attribute_checkpoint_expect__partial(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ExpectPartialResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void tensor_op_divide(::grpc::ClientContext* context, const ::yolo_tf::DivideRequest* request, ::yolo_tf::DivideResponse* response, std::function<void(::grpc::Status)>) override;
      void tensor_op_divide(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::DivideResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void tensor_op_divide(::grpc::ClientContext* context, const ::yolo_tf::DivideRequest* request, ::yolo_tf::DivideResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void tensor_op_divide(::grpc::ClientContext* context, const ::yolo_tf::DivideRequest* request, ::yolo_tf::DivideResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void tensor_op_divide(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::DivideResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void tensor_op_divide(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::DivideResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void iterable_indexing(::grpc::ClientContext* context, const ::yolo_tf::IndexingRequest* request, ::yolo_tf::IndexingResponse* response, std::function<void(::grpc::Status)>) override;
      void iterable_indexing(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::IndexingResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void iterable_indexing(::grpc::ClientContext* context, const ::yolo_tf::IndexingRequest* request, ::yolo_tf::IndexingResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void iterable_indexing(::grpc::ClientContext* context, const ::yolo_tf::IndexingRequest* request, ::yolo_tf::IndexingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void iterable_indexing(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::IndexingResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void iterable_indexing(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::IndexingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void byte_tensor_to_numpy(::grpc::ClientContext* context, const ::yolo_tf::TensorToNumpyRequest* request, ::yolo_tf::TensorToNumPyResponse* response, std::function<void(::grpc::Status)>) override;
      void byte_tensor_to_numpy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::TensorToNumPyResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void byte_tensor_to_numpy(::grpc::ClientContext* context, const ::yolo_tf::TensorToNumpyRequest* request, ::yolo_tf::TensorToNumPyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void byte_tensor_to_numpy(::grpc::ClientContext* context, const ::yolo_tf::TensorToNumpyRequest* request, ::yolo_tf::TensorToNumPyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void byte_tensor_to_numpy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::TensorToNumPyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void byte_tensor_to_numpy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::TensorToNumPyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void get_object_by_id(::grpc::ClientContext* context, const ::yolo_tf::GetObjectRequest* request, ::yolo_tf::GetObjectResponse* response, std::function<void(::grpc::Status)>) override;
      void get_object_by_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::GetObjectResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_object_by_id(::grpc::ClientContext* context, const ::yolo_tf::GetObjectRequest* request, ::yolo_tf::GetObjectResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_object_by_id(::grpc::ClientContext* context, const ::yolo_tf::GetObjectRequest* request, ::yolo_tf::GetObjectResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void get_object_by_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::GetObjectResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void get_object_by_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::GetObjectResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void batch_normalization(::grpc::ClientContext* context, const ::yolo_tf::BatchNormRequest* request, ::yolo_tf::BatchNormResponse* response, std::function<void(::grpc::Status)>) override;
      void batch_normalization(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::BatchNormResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void batch_normalization(::grpc::ClientContext* context, const ::yolo_tf::BatchNormRequest* request, ::yolo_tf::BatchNormResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void batch_normalization(::grpc::ClientContext* context, const ::yolo_tf::BatchNormRequest* request, ::yolo_tf::BatchNormResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void batch_normalization(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::BatchNormResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void batch_normalization(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::BatchNormResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::ConnectResponse>* AsyncConnectRaw(::grpc::ClientContext* context, const ::yolo_tf::ConnectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::ConnectResponse>* PrepareAsyncConnectRaw(::grpc::ClientContext* context, const ::yolo_tf::ConnectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::DisconnectResponse>* AsyncDisconnectRaw(::grpc::ClientContext* context, const ::yolo_tf::DisconnectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::DisconnectResponse>* PrepareAsyncDisconnectRaw(::grpc::ClientContext* context, const ::yolo_tf::DisconnectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::HelloReply>* AsyncSayHelloRaw(::grpc::ClientContext* context, const ::yolo_tf::HelloRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::HelloReply>* PrepareAsyncSayHelloRaw(::grpc::ClientContext* context, const ::yolo_tf::HelloRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::CallResponse>* Asynccallable_emulatorRaw(::grpc::ClientContext* context, const ::yolo_tf::CallRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::CallResponse>* PrepareAsynccallable_emulatorRaw(::grpc::ClientContext* context, const ::yolo_tf::CallRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::SlicingResponse>* Asyncget_iterable_slicingRaw(::grpc::ClientContext* context, const ::yolo_tf::SlicingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::SlicingResponse>* PrepareAsyncget_iterable_slicingRaw(::grpc::ClientContext* context, const ::yolo_tf::SlicingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::ConstantResponse>* AsyncconstantRaw(::grpc::ClientContext* context, const ::yolo_tf::ConstantRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::ConstantResponse>* PrepareAsyncconstantRaw(::grpc::ClientContext* context, const ::yolo_tf::ConstantRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::PhysicalDevices>* Asyncconfig_experimental_list__physical__devicesRaw(::grpc::ClientContext* context, const ::yolo_tf::DeviceType& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::PhysicalDevices>* PrepareAsyncconfig_experimental_list__physical__devicesRaw(::grpc::ClientContext* context, const ::yolo_tf::DeviceType& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::DecodeImageResponse>* Asyncimage_decode__imageRaw(::grpc::ClientContext* context, const ::yolo_tf::DecodeImageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::DecodeImageResponse>* PrepareAsyncimage_decode__imageRaw(::grpc::ClientContext* context, const ::yolo_tf::DecodeImageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::ExpandDemensionResponse>* Asyncexpand__dimsRaw(::grpc::ClientContext* context, const ::yolo_tf::ExpandDemensionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::ExpandDemensionResponse>* PrepareAsyncexpand__dimsRaw(::grpc::ClientContext* context, const ::yolo_tf::ExpandDemensionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::InputResponse>* Asynckeras_layers_InputRaw(::grpc::ClientContext* context, const ::yolo_tf::InputRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::InputResponse>* PrepareAsynckeras_layers_InputRaw(::grpc::ClientContext* context, const ::yolo_tf::InputRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::ModelResponse>* Asynckeras_ModelRaw(::grpc::ClientContext* context, const ::yolo_tf::ModelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::ModelResponse>* PrepareAsynckeras_ModelRaw(::grpc::ClientContext* context, const ::yolo_tf::ModelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::ZeroPadding2DResponse>* Asynckeras_layers_ZeroPadding2DRaw(::grpc::ClientContext* context, const ::yolo_tf::ZeroPadding2DRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::ZeroPadding2DResponse>* PrepareAsynckeras_layers_ZeroPadding2DRaw(::grpc::ClientContext* context, const ::yolo_tf::ZeroPadding2DRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::Conv2DResponse>* Asynckeras_layers_Conv2DRaw(::grpc::ClientContext* context, const ::yolo_tf::Conv2DRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::Conv2DResponse>* PrepareAsynckeras_layers_Conv2DRaw(::grpc::ClientContext* context, const ::yolo_tf::Conv2DRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::LeakyReluResponse>* Asynckeras_layers_LeakyReLURaw(::grpc::ClientContext* context, const ::yolo_tf::LeakyReluRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::LeakyReluResponse>* PrepareAsynckeras_layers_LeakyReLURaw(::grpc::ClientContext* context, const ::yolo_tf::LeakyReluRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::AddResponse>* Asynckeras_layers_AddRaw(::grpc::ClientContext* context, const ::yolo_tf::AddRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::AddResponse>* PrepareAsynckeras_layers_AddRaw(::grpc::ClientContext* context, const ::yolo_tf::AddRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::LambdaResponse>* Asynckeras_layers_LambdaRaw(::grpc::ClientContext* context, const ::yolo_tf::LambdaRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::LambdaResponse>* PrepareAsynckeras_layers_LambdaRaw(::grpc::ClientContext* context, const ::yolo_tf::LambdaRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::UpSampling2DResponse>* Asynckeras_layers_UpSampling2DRaw(::grpc::ClientContext* context, const ::yolo_tf::UpSampling2DRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::UpSampling2DResponse>* PrepareAsynckeras_layers_UpSampling2DRaw(::grpc::ClientContext* context, const ::yolo_tf::UpSampling2DRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::ContcatenateResponse>* Asynckeras_layers_ConcatenateRaw(::grpc::ClientContext* context, const ::yolo_tf::ConcatenateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::ContcatenateResponse>* PrepareAsynckeras_layers_ConcatenateRaw(::grpc::ClientContext* context, const ::yolo_tf::ConcatenateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::ImageResizeResponse>* Asyncimage_resizeRaw(::grpc::ClientContext* context, const ::yolo_tf::ImageResizeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::ImageResizeResponse>* PrepareAsyncimage_resizeRaw(::grpc::ClientContext* context, const ::yolo_tf::ImageResizeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::l2Response>* Asynckeras_regularizers_l2Raw(::grpc::ClientContext* context, const ::yolo_tf::l2Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::l2Response>* PrepareAsynckeras_regularizers_l2Raw(::grpc::ClientContext* context, const ::yolo_tf::l2Request& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::TensorShapeResponse>* Asyncattribute_tensor_shapeRaw(::grpc::ClientContext* context, const ::yolo_tf::TensorShapeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::TensorShapeResponse>* PrepareAsyncattribute_tensor_shapeRaw(::grpc::ClientContext* context, const ::yolo_tf::TensorShapeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::LoadWeightsResponse>* Asyncattribute_model_load__weightRaw(::grpc::ClientContext* context, const ::yolo_tf::LoadWeightsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::LoadWeightsResponse>* PrepareAsyncattribute_model_load__weightRaw(::grpc::ClientContext* context, const ::yolo_tf::LoadWeightsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::ExpectPartialResponse>* Asyncattribute_checkpoint_expect__partialRaw(::grpc::ClientContext* context, const ::yolo_tf::ExpectPartialRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::ExpectPartialResponse>* PrepareAsyncattribute_checkpoint_expect__partialRaw(::grpc::ClientContext* context, const ::yolo_tf::ExpectPartialRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::DivideResponse>* Asynctensor_op_divideRaw(::grpc::ClientContext* context, const ::yolo_tf::DivideRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::DivideResponse>* PrepareAsynctensor_op_divideRaw(::grpc::ClientContext* context, const ::yolo_tf::DivideRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::IndexingResponse>* Asynciterable_indexingRaw(::grpc::ClientContext* context, const ::yolo_tf::IndexingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::IndexingResponse>* PrepareAsynciterable_indexingRaw(::grpc::ClientContext* context, const ::yolo_tf::IndexingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::TensorToNumPyResponse>* Asyncbyte_tensor_to_numpyRaw(::grpc::ClientContext* context, const ::yolo_tf::TensorToNumpyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::TensorToNumPyResponse>* PrepareAsyncbyte_tensor_to_numpyRaw(::grpc::ClientContext* context, const ::yolo_tf::TensorToNumpyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::GetObjectResponse>* Asyncget_object_by_idRaw(::grpc::ClientContext* context, const ::yolo_tf::GetObjectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::GetObjectResponse>* PrepareAsyncget_object_by_idRaw(::grpc::ClientContext* context, const ::yolo_tf::GetObjectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::BatchNormResponse>* Asyncbatch_normalizationRaw(::grpc::ClientContext* context, const ::yolo_tf::BatchNormRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::yolo_tf::BatchNormResponse>* PrepareAsyncbatch_normalizationRaw(::grpc::ClientContext* context, const ::yolo_tf::BatchNormRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Connect_;
    const ::grpc::internal::RpcMethod rpcmethod_Disconnect_;
    const ::grpc::internal::RpcMethod rpcmethod_SayHello_;
    const ::grpc::internal::RpcMethod rpcmethod_callable_emulator_;
    const ::grpc::internal::RpcMethod rpcmethod_get_iterable_slicing_;
    const ::grpc::internal::RpcMethod rpcmethod_constant_;
    const ::grpc::internal::RpcMethod rpcmethod_config_experimental_list__physical__devices_;
    const ::grpc::internal::RpcMethod rpcmethod_image_decode__image_;
    const ::grpc::internal::RpcMethod rpcmethod_expand__dims_;
    const ::grpc::internal::RpcMethod rpcmethod_keras_layers_Input_;
    const ::grpc::internal::RpcMethod rpcmethod_keras_Model_;
    const ::grpc::internal::RpcMethod rpcmethod_keras_layers_ZeroPadding2D_;
    const ::grpc::internal::RpcMethod rpcmethod_keras_layers_Conv2D_;
    const ::grpc::internal::RpcMethod rpcmethod_keras_layers_LeakyReLU_;
    const ::grpc::internal::RpcMethod rpcmethod_keras_layers_Add_;
    const ::grpc::internal::RpcMethod rpcmethod_keras_layers_Lambda_;
    const ::grpc::internal::RpcMethod rpcmethod_keras_layers_UpSampling2D_;
    const ::grpc::internal::RpcMethod rpcmethod_keras_layers_Concatenate_;
    const ::grpc::internal::RpcMethod rpcmethod_image_resize_;
    const ::grpc::internal::RpcMethod rpcmethod_keras_regularizers_l2_;
    const ::grpc::internal::RpcMethod rpcmethod_attribute_tensor_shape_;
    const ::grpc::internal::RpcMethod rpcmethod_attribute_model_load__weight_;
    const ::grpc::internal::RpcMethod rpcmethod_attribute_checkpoint_expect__partial_;
    const ::grpc::internal::RpcMethod rpcmethod_tensor_op_divide_;
    const ::grpc::internal::RpcMethod rpcmethod_iterable_indexing_;
    const ::grpc::internal::RpcMethod rpcmethod_byte_tensor_to_numpy_;
    const ::grpc::internal::RpcMethod rpcmethod_get_object_by_id_;
    const ::grpc::internal::RpcMethod rpcmethod_batch_normalization_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Control Procedures
    virtual ::grpc::Status Connect(::grpc::ServerContext* context, const ::yolo_tf::ConnectRequest* request, ::yolo_tf::ConnectResponse* response);
    virtual ::grpc::Status Disconnect(::grpc::ServerContext* context, const ::yolo_tf::DisconnectRequest* request, ::yolo_tf::DisconnectResponse* response);
    // TF Wrappers
    virtual ::grpc::Status SayHello(::grpc::ServerContext* context, const ::yolo_tf::HelloRequest* request, ::yolo_tf::HelloReply* response);
    virtual ::grpc::Status callable_emulator(::grpc::ServerContext* context, const ::yolo_tf::CallRequest* request, ::yolo_tf::CallResponse* response);
    virtual ::grpc::Status get_iterable_slicing(::grpc::ServerContext* context, const ::yolo_tf::SlicingRequest* request, ::yolo_tf::SlicingResponse* response);
    virtual ::grpc::Status constant(::grpc::ServerContext* context, const ::yolo_tf::ConstantRequest* request, ::yolo_tf::ConstantResponse* response);
    virtual ::grpc::Status config_experimental_list__physical__devices(::grpc::ServerContext* context, const ::yolo_tf::DeviceType* request, ::yolo_tf::PhysicalDevices* response);
    virtual ::grpc::Status image_decode__image(::grpc::ServerContext* context, const ::yolo_tf::DecodeImageRequest* request, ::yolo_tf::DecodeImageResponse* response);
    virtual ::grpc::Status expand__dims(::grpc::ServerContext* context, const ::yolo_tf::ExpandDemensionRequest* request, ::yolo_tf::ExpandDemensionResponse* response);
    virtual ::grpc::Status keras_layers_Input(::grpc::ServerContext* context, const ::yolo_tf::InputRequest* request, ::yolo_tf::InputResponse* response);
    virtual ::grpc::Status keras_Model(::grpc::ServerContext* context, const ::yolo_tf::ModelRequest* request, ::yolo_tf::ModelResponse* response);
    virtual ::grpc::Status keras_layers_ZeroPadding2D(::grpc::ServerContext* context, const ::yolo_tf::ZeroPadding2DRequest* request, ::yolo_tf::ZeroPadding2DResponse* response);
    virtual ::grpc::Status keras_layers_Conv2D(::grpc::ServerContext* context, const ::yolo_tf::Conv2DRequest* request, ::yolo_tf::Conv2DResponse* response);
    virtual ::grpc::Status keras_layers_LeakyReLU(::grpc::ServerContext* context, const ::yolo_tf::LeakyReluRequest* request, ::yolo_tf::LeakyReluResponse* response);
    virtual ::grpc::Status keras_layers_Add(::grpc::ServerContext* context, const ::yolo_tf::AddRequest* request, ::yolo_tf::AddResponse* response);
    virtual ::grpc::Status keras_layers_Lambda(::grpc::ServerContext* context, const ::yolo_tf::LambdaRequest* request, ::yolo_tf::LambdaResponse* response);
    virtual ::grpc::Status keras_layers_UpSampling2D(::grpc::ServerContext* context, const ::yolo_tf::UpSampling2DRequest* request, ::yolo_tf::UpSampling2DResponse* response);
    virtual ::grpc::Status keras_layers_Concatenate(::grpc::ServerContext* context, const ::yolo_tf::ConcatenateRequest* request, ::yolo_tf::ContcatenateResponse* response);
    virtual ::grpc::Status image_resize(::grpc::ServerContext* context, const ::yolo_tf::ImageResizeRequest* request, ::yolo_tf::ImageResizeResponse* response);
    virtual ::grpc::Status keras_regularizers_l2(::grpc::ServerContext* context, const ::yolo_tf::l2Request* request, ::yolo_tf::l2Response* response);
    // attribute getters
    virtual ::grpc::Status attribute_tensor_shape(::grpc::ServerContext* context, const ::yolo_tf::TensorShapeRequest* request, ::yolo_tf::TensorShapeResponse* response);
    virtual ::grpc::Status attribute_model_load__weight(::grpc::ServerContext* context, const ::yolo_tf::LoadWeightsRequest* request, ::yolo_tf::LoadWeightsResponse* response);
    virtual ::grpc::Status attribute_checkpoint_expect__partial(::grpc::ServerContext* context, const ::yolo_tf::ExpectPartialRequest* request, ::yolo_tf::ExpectPartialResponse* response);
    // tensor operations
    virtual ::grpc::Status tensor_op_divide(::grpc::ServerContext* context, const ::yolo_tf::DivideRequest* request, ::yolo_tf::DivideResponse* response);
    // common operations
    virtual ::grpc::Status iterable_indexing(::grpc::ServerContext* context, const ::yolo_tf::IndexingRequest* request, ::yolo_tf::IndexingResponse* response);
    virtual ::grpc::Status byte_tensor_to_numpy(::grpc::ServerContext* context, const ::yolo_tf::TensorToNumpyRequest* request, ::yolo_tf::TensorToNumPyResponse* response);
    virtual ::grpc::Status get_object_by_id(::grpc::ServerContext* context, const ::yolo_tf::GetObjectRequest* request, ::yolo_tf::GetObjectResponse* response);
    // YoloWrappers
    virtual ::grpc::Status batch_normalization(::grpc::ServerContext* context, const ::yolo_tf::BatchNormRequest* request, ::yolo_tf::BatchNormResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Connect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Connect() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Connect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Connect(::grpc::ServerContext* /*context*/, const ::yolo_tf::ConnectRequest* /*request*/, ::yolo_tf::ConnectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConnect(::grpc::ServerContext* context, ::yolo_tf::ConnectRequest* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::ConnectResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Disconnect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Disconnect() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Disconnect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Disconnect(::grpc::ServerContext* /*context*/, const ::yolo_tf::DisconnectRequest* /*request*/, ::yolo_tf::DisconnectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisconnect(::grpc::ServerContext* context, ::yolo_tf::DisconnectRequest* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::DisconnectResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SayHello : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SayHello() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_SayHello() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SayHello(::grpc::ServerContext* /*context*/, const ::yolo_tf::HelloRequest* /*request*/, ::yolo_tf::HelloReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSayHello(::grpc::ServerContext* context, ::yolo_tf::HelloRequest* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::HelloReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_callable_emulator : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_callable_emulator() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_callable_emulator() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status callable_emulator(::grpc::ServerContext* /*context*/, const ::yolo_tf::CallRequest* /*request*/, ::yolo_tf::CallResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcallable_emulator(::grpc::ServerContext* context, ::yolo_tf::CallRequest* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::CallResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_iterable_slicing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_iterable_slicing() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_get_iterable_slicing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_iterable_slicing(::grpc::ServerContext* /*context*/, const ::yolo_tf::SlicingRequest* /*request*/, ::yolo_tf::SlicingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_iterable_slicing(::grpc::ServerContext* context, ::yolo_tf::SlicingRequest* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::SlicingResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_constant : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_constant() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_constant() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status constant(::grpc::ServerContext* /*context*/, const ::yolo_tf::ConstantRequest* /*request*/, ::yolo_tf::ConstantResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestconstant(::grpc::ServerContext* context, ::yolo_tf::ConstantRequest* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::ConstantResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_config_experimental_list__physical__devices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_config_experimental_list__physical__devices() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_config_experimental_list__physical__devices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status config_experimental_list__physical__devices(::grpc::ServerContext* /*context*/, const ::yolo_tf::DeviceType* /*request*/, ::yolo_tf::PhysicalDevices* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestconfig_experimental_list__physical__devices(::grpc::ServerContext* context, ::yolo_tf::DeviceType* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::PhysicalDevices>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_image_decode__image : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_image_decode__image() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_image_decode__image() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status image_decode__image(::grpc::ServerContext* /*context*/, const ::yolo_tf::DecodeImageRequest* /*request*/, ::yolo_tf::DecodeImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestimage_decode__image(::grpc::ServerContext* context, ::yolo_tf::DecodeImageRequest* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::DecodeImageResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_expand__dims : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_expand__dims() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_expand__dims() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status expand__dims(::grpc::ServerContext* /*context*/, const ::yolo_tf::ExpandDemensionRequest* /*request*/, ::yolo_tf::ExpandDemensionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestexpand__dims(::grpc::ServerContext* context, ::yolo_tf::ExpandDemensionRequest* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::ExpandDemensionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_keras_layers_Input : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_keras_layers_Input() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_keras_layers_Input() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_Input(::grpc::ServerContext* /*context*/, const ::yolo_tf::InputRequest* /*request*/, ::yolo_tf::InputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestkeras_layers_Input(::grpc::ServerContext* context, ::yolo_tf::InputRequest* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::InputResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_keras_Model : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_keras_Model() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_keras_Model() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_Model(::grpc::ServerContext* /*context*/, const ::yolo_tf::ModelRequest* /*request*/, ::yolo_tf::ModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestkeras_Model(::grpc::ServerContext* context, ::yolo_tf::ModelRequest* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::ModelResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_keras_layers_ZeroPadding2D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_keras_layers_ZeroPadding2D() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_keras_layers_ZeroPadding2D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_ZeroPadding2D(::grpc::ServerContext* /*context*/, const ::yolo_tf::ZeroPadding2DRequest* /*request*/, ::yolo_tf::ZeroPadding2DResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestkeras_layers_ZeroPadding2D(::grpc::ServerContext* context, ::yolo_tf::ZeroPadding2DRequest* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::ZeroPadding2DResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_keras_layers_Conv2D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_keras_layers_Conv2D() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_keras_layers_Conv2D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_Conv2D(::grpc::ServerContext* /*context*/, const ::yolo_tf::Conv2DRequest* /*request*/, ::yolo_tf::Conv2DResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestkeras_layers_Conv2D(::grpc::ServerContext* context, ::yolo_tf::Conv2DRequest* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::Conv2DResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_keras_layers_LeakyReLU : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_keras_layers_LeakyReLU() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_keras_layers_LeakyReLU() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_LeakyReLU(::grpc::ServerContext* /*context*/, const ::yolo_tf::LeakyReluRequest* /*request*/, ::yolo_tf::LeakyReluResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestkeras_layers_LeakyReLU(::grpc::ServerContext* context, ::yolo_tf::LeakyReluRequest* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::LeakyReluResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_keras_layers_Add : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_keras_layers_Add() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_keras_layers_Add() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_Add(::grpc::ServerContext* /*context*/, const ::yolo_tf::AddRequest* /*request*/, ::yolo_tf::AddResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestkeras_layers_Add(::grpc::ServerContext* context, ::yolo_tf::AddRequest* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::AddResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_keras_layers_Lambda : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_keras_layers_Lambda() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_keras_layers_Lambda() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_Lambda(::grpc::ServerContext* /*context*/, const ::yolo_tf::LambdaRequest* /*request*/, ::yolo_tf::LambdaResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestkeras_layers_Lambda(::grpc::ServerContext* context, ::yolo_tf::LambdaRequest* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::LambdaResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_keras_layers_UpSampling2D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_keras_layers_UpSampling2D() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_keras_layers_UpSampling2D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_UpSampling2D(::grpc::ServerContext* /*context*/, const ::yolo_tf::UpSampling2DRequest* /*request*/, ::yolo_tf::UpSampling2DResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestkeras_layers_UpSampling2D(::grpc::ServerContext* context, ::yolo_tf::UpSampling2DRequest* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::UpSampling2DResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_keras_layers_Concatenate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_keras_layers_Concatenate() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_keras_layers_Concatenate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_Concatenate(::grpc::ServerContext* /*context*/, const ::yolo_tf::ConcatenateRequest* /*request*/, ::yolo_tf::ContcatenateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestkeras_layers_Concatenate(::grpc::ServerContext* context, ::yolo_tf::ConcatenateRequest* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::ContcatenateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_image_resize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_image_resize() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_image_resize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status image_resize(::grpc::ServerContext* /*context*/, const ::yolo_tf::ImageResizeRequest* /*request*/, ::yolo_tf::ImageResizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestimage_resize(::grpc::ServerContext* context, ::yolo_tf::ImageResizeRequest* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::ImageResizeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_keras_regularizers_l2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_keras_regularizers_l2() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_keras_regularizers_l2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_regularizers_l2(::grpc::ServerContext* /*context*/, const ::yolo_tf::l2Request* /*request*/, ::yolo_tf::l2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestkeras_regularizers_l2(::grpc::ServerContext* context, ::yolo_tf::l2Request* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::l2Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_attribute_tensor_shape : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_attribute_tensor_shape() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_attribute_tensor_shape() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status attribute_tensor_shape(::grpc::ServerContext* /*context*/, const ::yolo_tf::TensorShapeRequest* /*request*/, ::yolo_tf::TensorShapeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestattribute_tensor_shape(::grpc::ServerContext* context, ::yolo_tf::TensorShapeRequest* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::TensorShapeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_attribute_model_load__weight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_attribute_model_load__weight() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_attribute_model_load__weight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status attribute_model_load__weight(::grpc::ServerContext* /*context*/, const ::yolo_tf::LoadWeightsRequest* /*request*/, ::yolo_tf::LoadWeightsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestattribute_model_load__weight(::grpc::ServerContext* context, ::yolo_tf::LoadWeightsRequest* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::LoadWeightsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_attribute_checkpoint_expect__partial : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_attribute_checkpoint_expect__partial() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_attribute_checkpoint_expect__partial() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status attribute_checkpoint_expect__partial(::grpc::ServerContext* /*context*/, const ::yolo_tf::ExpectPartialRequest* /*request*/, ::yolo_tf::ExpectPartialResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestattribute_checkpoint_expect__partial(::grpc::ServerContext* context, ::yolo_tf::ExpectPartialRequest* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::ExpectPartialResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_tensor_op_divide : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_tensor_op_divide() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_tensor_op_divide() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status tensor_op_divide(::grpc::ServerContext* /*context*/, const ::yolo_tf::DivideRequest* /*request*/, ::yolo_tf::DivideResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttensor_op_divide(::grpc::ServerContext* context, ::yolo_tf::DivideRequest* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::DivideResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_iterable_indexing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_iterable_indexing() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_iterable_indexing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status iterable_indexing(::grpc::ServerContext* /*context*/, const ::yolo_tf::IndexingRequest* /*request*/, ::yolo_tf::IndexingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestiterable_indexing(::grpc::ServerContext* context, ::yolo_tf::IndexingRequest* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::IndexingResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_byte_tensor_to_numpy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_byte_tensor_to_numpy() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_byte_tensor_to_numpy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status byte_tensor_to_numpy(::grpc::ServerContext* /*context*/, const ::yolo_tf::TensorToNumpyRequest* /*request*/, ::yolo_tf::TensorToNumPyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestbyte_tensor_to_numpy(::grpc::ServerContext* context, ::yolo_tf::TensorToNumpyRequest* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::TensorToNumPyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_object_by_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_object_by_id() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_get_object_by_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_object_by_id(::grpc::ServerContext* /*context*/, const ::yolo_tf::GetObjectRequest* /*request*/, ::yolo_tf::GetObjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_object_by_id(::grpc::ServerContext* context, ::yolo_tf::GetObjectRequest* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::GetObjectResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_batch_normalization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_batch_normalization() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_batch_normalization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status batch_normalization(::grpc::ServerContext* /*context*/, const ::yolo_tf::BatchNormRequest* /*request*/, ::yolo_tf::BatchNormResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestbatch_normalization(::grpc::ServerContext* context, ::yolo_tf::BatchNormRequest* request, ::grpc::ServerAsyncResponseWriter< ::yolo_tf::BatchNormResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Connect<WithAsyncMethod_Disconnect<WithAsyncMethod_SayHello<WithAsyncMethod_callable_emulator<WithAsyncMethod_get_iterable_slicing<WithAsyncMethod_constant<WithAsyncMethod_config_experimental_list__physical__devices<WithAsyncMethod_image_decode__image<WithAsyncMethod_expand__dims<WithAsyncMethod_keras_layers_Input<WithAsyncMethod_keras_Model<WithAsyncMethod_keras_layers_ZeroPadding2D<WithAsyncMethod_keras_layers_Conv2D<WithAsyncMethod_keras_layers_LeakyReLU<WithAsyncMethod_keras_layers_Add<WithAsyncMethod_keras_layers_Lambda<WithAsyncMethod_keras_layers_UpSampling2D<WithAsyncMethod_keras_layers_Concatenate<WithAsyncMethod_image_resize<WithAsyncMethod_keras_regularizers_l2<WithAsyncMethod_attribute_tensor_shape<WithAsyncMethod_attribute_model_load__weight<WithAsyncMethod_attribute_checkpoint_expect__partial<WithAsyncMethod_tensor_op_divide<WithAsyncMethod_iterable_indexing<WithAsyncMethod_byte_tensor_to_numpy<WithAsyncMethod_get_object_by_id<WithAsyncMethod_batch_normalization<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Connect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Connect() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::ConnectRequest, ::yolo_tf::ConnectResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::ConnectRequest* request, ::yolo_tf::ConnectResponse* response) { return this->Connect(context, request, response); }));}
    void SetMessageAllocatorFor_Connect(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::ConnectRequest, ::yolo_tf::ConnectResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::ConnectRequest, ::yolo_tf::ConnectResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Connect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Connect(::grpc::ServerContext* /*context*/, const ::yolo_tf::ConnectRequest* /*request*/, ::yolo_tf::ConnectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Connect(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::ConnectRequest* /*request*/, ::yolo_tf::ConnectResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Connect(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::ConnectRequest* /*request*/, ::yolo_tf::ConnectResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Disconnect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Disconnect() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::DisconnectRequest, ::yolo_tf::DisconnectResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::DisconnectRequest* request, ::yolo_tf::DisconnectResponse* response) { return this->Disconnect(context, request, response); }));}
    void SetMessageAllocatorFor_Disconnect(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::DisconnectRequest, ::yolo_tf::DisconnectResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::DisconnectRequest, ::yolo_tf::DisconnectResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Disconnect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Disconnect(::grpc::ServerContext* /*context*/, const ::yolo_tf::DisconnectRequest* /*request*/, ::yolo_tf::DisconnectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Disconnect(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::DisconnectRequest* /*request*/, ::yolo_tf::DisconnectResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Disconnect(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::DisconnectRequest* /*request*/, ::yolo_tf::DisconnectResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SayHello : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SayHello() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::HelloRequest, ::yolo_tf::HelloReply>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::HelloRequest* request, ::yolo_tf::HelloReply* response) { return this->SayHello(context, request, response); }));}
    void SetMessageAllocatorFor_SayHello(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::HelloRequest, ::yolo_tf::HelloReply>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::HelloRequest, ::yolo_tf::HelloReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SayHello() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SayHello(::grpc::ServerContext* /*context*/, const ::yolo_tf::HelloRequest* /*request*/, ::yolo_tf::HelloReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SayHello(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::HelloRequest* /*request*/, ::yolo_tf::HelloReply* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SayHello(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::HelloRequest* /*request*/, ::yolo_tf::HelloReply* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_callable_emulator : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_callable_emulator() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::CallRequest, ::yolo_tf::CallResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::CallRequest* request, ::yolo_tf::CallResponse* response) { return this->callable_emulator(context, request, response); }));}
    void SetMessageAllocatorFor_callable_emulator(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::CallRequest, ::yolo_tf::CallResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::CallRequest, ::yolo_tf::CallResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_callable_emulator() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status callable_emulator(::grpc::ServerContext* /*context*/, const ::yolo_tf::CallRequest* /*request*/, ::yolo_tf::CallResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* callable_emulator(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::CallRequest* /*request*/, ::yolo_tf::CallResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* callable_emulator(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::CallRequest* /*request*/, ::yolo_tf::CallResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_get_iterable_slicing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_get_iterable_slicing() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::SlicingRequest, ::yolo_tf::SlicingResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::SlicingRequest* request, ::yolo_tf::SlicingResponse* response) { return this->get_iterable_slicing(context, request, response); }));}
    void SetMessageAllocatorFor_get_iterable_slicing(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::SlicingRequest, ::yolo_tf::SlicingResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::SlicingRequest, ::yolo_tf::SlicingResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_get_iterable_slicing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_iterable_slicing(::grpc::ServerContext* /*context*/, const ::yolo_tf::SlicingRequest* /*request*/, ::yolo_tf::SlicingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_iterable_slicing(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::SlicingRequest* /*request*/, ::yolo_tf::SlicingResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_iterable_slicing(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::SlicingRequest* /*request*/, ::yolo_tf::SlicingResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_constant : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_constant() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::ConstantRequest, ::yolo_tf::ConstantResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::ConstantRequest* request, ::yolo_tf::ConstantResponse* response) { return this->constant(context, request, response); }));}
    void SetMessageAllocatorFor_constant(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::ConstantRequest, ::yolo_tf::ConstantResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::ConstantRequest, ::yolo_tf::ConstantResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_constant() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status constant(::grpc::ServerContext* /*context*/, const ::yolo_tf::ConstantRequest* /*request*/, ::yolo_tf::ConstantResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* constant(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::ConstantRequest* /*request*/, ::yolo_tf::ConstantResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* constant(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::ConstantRequest* /*request*/, ::yolo_tf::ConstantResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_config_experimental_list__physical__devices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_config_experimental_list__physical__devices() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::DeviceType, ::yolo_tf::PhysicalDevices>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::DeviceType* request, ::yolo_tf::PhysicalDevices* response) { return this->config_experimental_list__physical__devices(context, request, response); }));}
    void SetMessageAllocatorFor_config_experimental_list__physical__devices(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::DeviceType, ::yolo_tf::PhysicalDevices>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::DeviceType, ::yolo_tf::PhysicalDevices>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_config_experimental_list__physical__devices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status config_experimental_list__physical__devices(::grpc::ServerContext* /*context*/, const ::yolo_tf::DeviceType* /*request*/, ::yolo_tf::PhysicalDevices* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* config_experimental_list__physical__devices(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::DeviceType* /*request*/, ::yolo_tf::PhysicalDevices* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* config_experimental_list__physical__devices(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::DeviceType* /*request*/, ::yolo_tf::PhysicalDevices* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_image_decode__image : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_image_decode__image() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::DecodeImageRequest, ::yolo_tf::DecodeImageResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::DecodeImageRequest* request, ::yolo_tf::DecodeImageResponse* response) { return this->image_decode__image(context, request, response); }));}
    void SetMessageAllocatorFor_image_decode__image(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::DecodeImageRequest, ::yolo_tf::DecodeImageResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::DecodeImageRequest, ::yolo_tf::DecodeImageResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_image_decode__image() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status image_decode__image(::grpc::ServerContext* /*context*/, const ::yolo_tf::DecodeImageRequest* /*request*/, ::yolo_tf::DecodeImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* image_decode__image(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::DecodeImageRequest* /*request*/, ::yolo_tf::DecodeImageResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* image_decode__image(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::DecodeImageRequest* /*request*/, ::yolo_tf::DecodeImageResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_expand__dims : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_expand__dims() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::ExpandDemensionRequest, ::yolo_tf::ExpandDemensionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::ExpandDemensionRequest* request, ::yolo_tf::ExpandDemensionResponse* response) { return this->expand__dims(context, request, response); }));}
    void SetMessageAllocatorFor_expand__dims(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::ExpandDemensionRequest, ::yolo_tf::ExpandDemensionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::ExpandDemensionRequest, ::yolo_tf::ExpandDemensionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_expand__dims() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status expand__dims(::grpc::ServerContext* /*context*/, const ::yolo_tf::ExpandDemensionRequest* /*request*/, ::yolo_tf::ExpandDemensionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* expand__dims(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::ExpandDemensionRequest* /*request*/, ::yolo_tf::ExpandDemensionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* expand__dims(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::ExpandDemensionRequest* /*request*/, ::yolo_tf::ExpandDemensionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_keras_layers_Input : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_keras_layers_Input() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::InputRequest, ::yolo_tf::InputResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::InputRequest* request, ::yolo_tf::InputResponse* response) { return this->keras_layers_Input(context, request, response); }));}
    void SetMessageAllocatorFor_keras_layers_Input(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::InputRequest, ::yolo_tf::InputResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::InputRequest, ::yolo_tf::InputResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_keras_layers_Input() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_Input(::grpc::ServerContext* /*context*/, const ::yolo_tf::InputRequest* /*request*/, ::yolo_tf::InputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* keras_layers_Input(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::InputRequest* /*request*/, ::yolo_tf::InputResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* keras_layers_Input(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::InputRequest* /*request*/, ::yolo_tf::InputResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_keras_Model : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_keras_Model() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::ModelRequest, ::yolo_tf::ModelResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::ModelRequest* request, ::yolo_tf::ModelResponse* response) { return this->keras_Model(context, request, response); }));}
    void SetMessageAllocatorFor_keras_Model(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::ModelRequest, ::yolo_tf::ModelResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::ModelRequest, ::yolo_tf::ModelResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_keras_Model() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_Model(::grpc::ServerContext* /*context*/, const ::yolo_tf::ModelRequest* /*request*/, ::yolo_tf::ModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* keras_Model(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::ModelRequest* /*request*/, ::yolo_tf::ModelResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* keras_Model(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::ModelRequest* /*request*/, ::yolo_tf::ModelResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_keras_layers_ZeroPadding2D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_keras_layers_ZeroPadding2D() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::ZeroPadding2DRequest, ::yolo_tf::ZeroPadding2DResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::ZeroPadding2DRequest* request, ::yolo_tf::ZeroPadding2DResponse* response) { return this->keras_layers_ZeroPadding2D(context, request, response); }));}
    void SetMessageAllocatorFor_keras_layers_ZeroPadding2D(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::ZeroPadding2DRequest, ::yolo_tf::ZeroPadding2DResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::ZeroPadding2DRequest, ::yolo_tf::ZeroPadding2DResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_keras_layers_ZeroPadding2D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_ZeroPadding2D(::grpc::ServerContext* /*context*/, const ::yolo_tf::ZeroPadding2DRequest* /*request*/, ::yolo_tf::ZeroPadding2DResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* keras_layers_ZeroPadding2D(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::ZeroPadding2DRequest* /*request*/, ::yolo_tf::ZeroPadding2DResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* keras_layers_ZeroPadding2D(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::ZeroPadding2DRequest* /*request*/, ::yolo_tf::ZeroPadding2DResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_keras_layers_Conv2D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_keras_layers_Conv2D() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::Conv2DRequest, ::yolo_tf::Conv2DResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::Conv2DRequest* request, ::yolo_tf::Conv2DResponse* response) { return this->keras_layers_Conv2D(context, request, response); }));}
    void SetMessageAllocatorFor_keras_layers_Conv2D(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::Conv2DRequest, ::yolo_tf::Conv2DResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::Conv2DRequest, ::yolo_tf::Conv2DResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_keras_layers_Conv2D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_Conv2D(::grpc::ServerContext* /*context*/, const ::yolo_tf::Conv2DRequest* /*request*/, ::yolo_tf::Conv2DResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* keras_layers_Conv2D(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::Conv2DRequest* /*request*/, ::yolo_tf::Conv2DResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* keras_layers_Conv2D(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::Conv2DRequest* /*request*/, ::yolo_tf::Conv2DResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_keras_layers_LeakyReLU : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_keras_layers_LeakyReLU() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::LeakyReluRequest, ::yolo_tf::LeakyReluResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::LeakyReluRequest* request, ::yolo_tf::LeakyReluResponse* response) { return this->keras_layers_LeakyReLU(context, request, response); }));}
    void SetMessageAllocatorFor_keras_layers_LeakyReLU(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::LeakyReluRequest, ::yolo_tf::LeakyReluResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::LeakyReluRequest, ::yolo_tf::LeakyReluResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_keras_layers_LeakyReLU() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_LeakyReLU(::grpc::ServerContext* /*context*/, const ::yolo_tf::LeakyReluRequest* /*request*/, ::yolo_tf::LeakyReluResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* keras_layers_LeakyReLU(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::LeakyReluRequest* /*request*/, ::yolo_tf::LeakyReluResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* keras_layers_LeakyReLU(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::LeakyReluRequest* /*request*/, ::yolo_tf::LeakyReluResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_keras_layers_Add : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_keras_layers_Add() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(14,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::AddRequest, ::yolo_tf::AddResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::AddRequest* request, ::yolo_tf::AddResponse* response) { return this->keras_layers_Add(context, request, response); }));}
    void SetMessageAllocatorFor_keras_layers_Add(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::AddRequest, ::yolo_tf::AddResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(14);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::AddRequest, ::yolo_tf::AddResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_keras_layers_Add() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_Add(::grpc::ServerContext* /*context*/, const ::yolo_tf::AddRequest* /*request*/, ::yolo_tf::AddResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* keras_layers_Add(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::AddRequest* /*request*/, ::yolo_tf::AddResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* keras_layers_Add(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::AddRequest* /*request*/, ::yolo_tf::AddResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_keras_layers_Lambda : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_keras_layers_Lambda() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(15,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::LambdaRequest, ::yolo_tf::LambdaResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::LambdaRequest* request, ::yolo_tf::LambdaResponse* response) { return this->keras_layers_Lambda(context, request, response); }));}
    void SetMessageAllocatorFor_keras_layers_Lambda(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::LambdaRequest, ::yolo_tf::LambdaResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(15);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::LambdaRequest, ::yolo_tf::LambdaResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_keras_layers_Lambda() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_Lambda(::grpc::ServerContext* /*context*/, const ::yolo_tf::LambdaRequest* /*request*/, ::yolo_tf::LambdaResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* keras_layers_Lambda(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::LambdaRequest* /*request*/, ::yolo_tf::LambdaResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* keras_layers_Lambda(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::LambdaRequest* /*request*/, ::yolo_tf::LambdaResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_keras_layers_UpSampling2D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_keras_layers_UpSampling2D() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(16,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::UpSampling2DRequest, ::yolo_tf::UpSampling2DResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::UpSampling2DRequest* request, ::yolo_tf::UpSampling2DResponse* response) { return this->keras_layers_UpSampling2D(context, request, response); }));}
    void SetMessageAllocatorFor_keras_layers_UpSampling2D(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::UpSampling2DRequest, ::yolo_tf::UpSampling2DResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(16);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::UpSampling2DRequest, ::yolo_tf::UpSampling2DResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_keras_layers_UpSampling2D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_UpSampling2D(::grpc::ServerContext* /*context*/, const ::yolo_tf::UpSampling2DRequest* /*request*/, ::yolo_tf::UpSampling2DResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* keras_layers_UpSampling2D(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::UpSampling2DRequest* /*request*/, ::yolo_tf::UpSampling2DResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* keras_layers_UpSampling2D(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::UpSampling2DRequest* /*request*/, ::yolo_tf::UpSampling2DResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_keras_layers_Concatenate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_keras_layers_Concatenate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(17,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::ConcatenateRequest, ::yolo_tf::ContcatenateResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::ConcatenateRequest* request, ::yolo_tf::ContcatenateResponse* response) { return this->keras_layers_Concatenate(context, request, response); }));}
    void SetMessageAllocatorFor_keras_layers_Concatenate(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::ConcatenateRequest, ::yolo_tf::ContcatenateResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(17);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::ConcatenateRequest, ::yolo_tf::ContcatenateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_keras_layers_Concatenate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_Concatenate(::grpc::ServerContext* /*context*/, const ::yolo_tf::ConcatenateRequest* /*request*/, ::yolo_tf::ContcatenateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* keras_layers_Concatenate(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::ConcatenateRequest* /*request*/, ::yolo_tf::ContcatenateResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* keras_layers_Concatenate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::ConcatenateRequest* /*request*/, ::yolo_tf::ContcatenateResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_image_resize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_image_resize() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(18,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::ImageResizeRequest, ::yolo_tf::ImageResizeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::ImageResizeRequest* request, ::yolo_tf::ImageResizeResponse* response) { return this->image_resize(context, request, response); }));}
    void SetMessageAllocatorFor_image_resize(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::ImageResizeRequest, ::yolo_tf::ImageResizeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(18);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::ImageResizeRequest, ::yolo_tf::ImageResizeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_image_resize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status image_resize(::grpc::ServerContext* /*context*/, const ::yolo_tf::ImageResizeRequest* /*request*/, ::yolo_tf::ImageResizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* image_resize(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::ImageResizeRequest* /*request*/, ::yolo_tf::ImageResizeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* image_resize(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::ImageResizeRequest* /*request*/, ::yolo_tf::ImageResizeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_keras_regularizers_l2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_keras_regularizers_l2() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(19,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::l2Request, ::yolo_tf::l2Response>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::l2Request* request, ::yolo_tf::l2Response* response) { return this->keras_regularizers_l2(context, request, response); }));}
    void SetMessageAllocatorFor_keras_regularizers_l2(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::l2Request, ::yolo_tf::l2Response>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(19);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::l2Request, ::yolo_tf::l2Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_keras_regularizers_l2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_regularizers_l2(::grpc::ServerContext* /*context*/, const ::yolo_tf::l2Request* /*request*/, ::yolo_tf::l2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* keras_regularizers_l2(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::l2Request* /*request*/, ::yolo_tf::l2Response* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* keras_regularizers_l2(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::l2Request* /*request*/, ::yolo_tf::l2Response* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_attribute_tensor_shape : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_attribute_tensor_shape() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(20,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::TensorShapeRequest, ::yolo_tf::TensorShapeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::TensorShapeRequest* request, ::yolo_tf::TensorShapeResponse* response) { return this->attribute_tensor_shape(context, request, response); }));}
    void SetMessageAllocatorFor_attribute_tensor_shape(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::TensorShapeRequest, ::yolo_tf::TensorShapeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(20);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::TensorShapeRequest, ::yolo_tf::TensorShapeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_attribute_tensor_shape() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status attribute_tensor_shape(::grpc::ServerContext* /*context*/, const ::yolo_tf::TensorShapeRequest* /*request*/, ::yolo_tf::TensorShapeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* attribute_tensor_shape(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::TensorShapeRequest* /*request*/, ::yolo_tf::TensorShapeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* attribute_tensor_shape(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::TensorShapeRequest* /*request*/, ::yolo_tf::TensorShapeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_attribute_model_load__weight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_attribute_model_load__weight() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(21,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::LoadWeightsRequest, ::yolo_tf::LoadWeightsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::LoadWeightsRequest* request, ::yolo_tf::LoadWeightsResponse* response) { return this->attribute_model_load__weight(context, request, response); }));}
    void SetMessageAllocatorFor_attribute_model_load__weight(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::LoadWeightsRequest, ::yolo_tf::LoadWeightsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(21);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::LoadWeightsRequest, ::yolo_tf::LoadWeightsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_attribute_model_load__weight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status attribute_model_load__weight(::grpc::ServerContext* /*context*/, const ::yolo_tf::LoadWeightsRequest* /*request*/, ::yolo_tf::LoadWeightsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* attribute_model_load__weight(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::LoadWeightsRequest* /*request*/, ::yolo_tf::LoadWeightsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* attribute_model_load__weight(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::LoadWeightsRequest* /*request*/, ::yolo_tf::LoadWeightsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_attribute_checkpoint_expect__partial : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_attribute_checkpoint_expect__partial() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(22,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::ExpectPartialRequest, ::yolo_tf::ExpectPartialResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::ExpectPartialRequest* request, ::yolo_tf::ExpectPartialResponse* response) { return this->attribute_checkpoint_expect__partial(context, request, response); }));}
    void SetMessageAllocatorFor_attribute_checkpoint_expect__partial(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::ExpectPartialRequest, ::yolo_tf::ExpectPartialResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(22);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::ExpectPartialRequest, ::yolo_tf::ExpectPartialResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_attribute_checkpoint_expect__partial() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status attribute_checkpoint_expect__partial(::grpc::ServerContext* /*context*/, const ::yolo_tf::ExpectPartialRequest* /*request*/, ::yolo_tf::ExpectPartialResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* attribute_checkpoint_expect__partial(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::ExpectPartialRequest* /*request*/, ::yolo_tf::ExpectPartialResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* attribute_checkpoint_expect__partial(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::ExpectPartialRequest* /*request*/, ::yolo_tf::ExpectPartialResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_tensor_op_divide : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_tensor_op_divide() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(23,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::DivideRequest, ::yolo_tf::DivideResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::DivideRequest* request, ::yolo_tf::DivideResponse* response) { return this->tensor_op_divide(context, request, response); }));}
    void SetMessageAllocatorFor_tensor_op_divide(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::DivideRequest, ::yolo_tf::DivideResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(23);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::DivideRequest, ::yolo_tf::DivideResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_tensor_op_divide() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status tensor_op_divide(::grpc::ServerContext* /*context*/, const ::yolo_tf::DivideRequest* /*request*/, ::yolo_tf::DivideResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* tensor_op_divide(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::DivideRequest* /*request*/, ::yolo_tf::DivideResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* tensor_op_divide(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::DivideRequest* /*request*/, ::yolo_tf::DivideResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_iterable_indexing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_iterable_indexing() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(24,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::IndexingRequest, ::yolo_tf::IndexingResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::IndexingRequest* request, ::yolo_tf::IndexingResponse* response) { return this->iterable_indexing(context, request, response); }));}
    void SetMessageAllocatorFor_iterable_indexing(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::IndexingRequest, ::yolo_tf::IndexingResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(24);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(24);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::IndexingRequest, ::yolo_tf::IndexingResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_iterable_indexing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status iterable_indexing(::grpc::ServerContext* /*context*/, const ::yolo_tf::IndexingRequest* /*request*/, ::yolo_tf::IndexingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* iterable_indexing(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::IndexingRequest* /*request*/, ::yolo_tf::IndexingResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* iterable_indexing(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::IndexingRequest* /*request*/, ::yolo_tf::IndexingResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_byte_tensor_to_numpy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_byte_tensor_to_numpy() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(25,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::TensorToNumpyRequest, ::yolo_tf::TensorToNumPyResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::TensorToNumpyRequest* request, ::yolo_tf::TensorToNumPyResponse* response) { return this->byte_tensor_to_numpy(context, request, response); }));}
    void SetMessageAllocatorFor_byte_tensor_to_numpy(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::TensorToNumpyRequest, ::yolo_tf::TensorToNumPyResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(25);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(25);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::TensorToNumpyRequest, ::yolo_tf::TensorToNumPyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_byte_tensor_to_numpy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status byte_tensor_to_numpy(::grpc::ServerContext* /*context*/, const ::yolo_tf::TensorToNumpyRequest* /*request*/, ::yolo_tf::TensorToNumPyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* byte_tensor_to_numpy(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::TensorToNumpyRequest* /*request*/, ::yolo_tf::TensorToNumPyResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* byte_tensor_to_numpy(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::TensorToNumpyRequest* /*request*/, ::yolo_tf::TensorToNumPyResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_get_object_by_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_get_object_by_id() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(26,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::GetObjectRequest, ::yolo_tf::GetObjectResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::GetObjectRequest* request, ::yolo_tf::GetObjectResponse* response) { return this->get_object_by_id(context, request, response); }));}
    void SetMessageAllocatorFor_get_object_by_id(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::GetObjectRequest, ::yolo_tf::GetObjectResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(26);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(26);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::GetObjectRequest, ::yolo_tf::GetObjectResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_get_object_by_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_object_by_id(::grpc::ServerContext* /*context*/, const ::yolo_tf::GetObjectRequest* /*request*/, ::yolo_tf::GetObjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_object_by_id(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::GetObjectRequest* /*request*/, ::yolo_tf::GetObjectResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_object_by_id(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::GetObjectRequest* /*request*/, ::yolo_tf::GetObjectResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_batch_normalization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_batch_normalization() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(27,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::BatchNormRequest, ::yolo_tf::BatchNormResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::yolo_tf::BatchNormRequest* request, ::yolo_tf::BatchNormResponse* response) { return this->batch_normalization(context, request, response); }));}
    void SetMessageAllocatorFor_batch_normalization(
        ::grpc::experimental::MessageAllocator< ::yolo_tf::BatchNormRequest, ::yolo_tf::BatchNormResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(27);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(27);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::yolo_tf::BatchNormRequest, ::yolo_tf::BatchNormResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_batch_normalization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status batch_normalization(::grpc::ServerContext* /*context*/, const ::yolo_tf::BatchNormRequest* /*request*/, ::yolo_tf::BatchNormResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* batch_normalization(
      ::grpc::CallbackServerContext* /*context*/, const ::yolo_tf::BatchNormRequest* /*request*/, ::yolo_tf::BatchNormResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* batch_normalization(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::yolo_tf::BatchNormRequest* /*request*/, ::yolo_tf::BatchNormResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_Connect<ExperimentalWithCallbackMethod_Disconnect<ExperimentalWithCallbackMethod_SayHello<ExperimentalWithCallbackMethod_callable_emulator<ExperimentalWithCallbackMethod_get_iterable_slicing<ExperimentalWithCallbackMethod_constant<ExperimentalWithCallbackMethod_config_experimental_list__physical__devices<ExperimentalWithCallbackMethod_image_decode__image<ExperimentalWithCallbackMethod_expand__dims<ExperimentalWithCallbackMethod_keras_layers_Input<ExperimentalWithCallbackMethod_keras_Model<ExperimentalWithCallbackMethod_keras_layers_ZeroPadding2D<ExperimentalWithCallbackMethod_keras_layers_Conv2D<ExperimentalWithCallbackMethod_keras_layers_LeakyReLU<ExperimentalWithCallbackMethod_keras_layers_Add<ExperimentalWithCallbackMethod_keras_layers_Lambda<ExperimentalWithCallbackMethod_keras_layers_UpSampling2D<ExperimentalWithCallbackMethod_keras_layers_Concatenate<ExperimentalWithCallbackMethod_image_resize<ExperimentalWithCallbackMethod_keras_regularizers_l2<ExperimentalWithCallbackMethod_attribute_tensor_shape<ExperimentalWithCallbackMethod_attribute_model_load__weight<ExperimentalWithCallbackMethod_attribute_checkpoint_expect__partial<ExperimentalWithCallbackMethod_tensor_op_divide<ExperimentalWithCallbackMethod_iterable_indexing<ExperimentalWithCallbackMethod_byte_tensor_to_numpy<ExperimentalWithCallbackMethod_get_object_by_id<ExperimentalWithCallbackMethod_batch_normalization<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_Connect<ExperimentalWithCallbackMethod_Disconnect<ExperimentalWithCallbackMethod_SayHello<ExperimentalWithCallbackMethod_callable_emulator<ExperimentalWithCallbackMethod_get_iterable_slicing<ExperimentalWithCallbackMethod_constant<ExperimentalWithCallbackMethod_config_experimental_list__physical__devices<ExperimentalWithCallbackMethod_image_decode__image<ExperimentalWithCallbackMethod_expand__dims<ExperimentalWithCallbackMethod_keras_layers_Input<ExperimentalWithCallbackMethod_keras_Model<ExperimentalWithCallbackMethod_keras_layers_ZeroPadding2D<ExperimentalWithCallbackMethod_keras_layers_Conv2D<ExperimentalWithCallbackMethod_keras_layers_LeakyReLU<ExperimentalWithCallbackMethod_keras_layers_Add<ExperimentalWithCallbackMethod_keras_layers_Lambda<ExperimentalWithCallbackMethod_keras_layers_UpSampling2D<ExperimentalWithCallbackMethod_keras_layers_Concatenate<ExperimentalWithCallbackMethod_image_resize<ExperimentalWithCallbackMethod_keras_regularizers_l2<ExperimentalWithCallbackMethod_attribute_tensor_shape<ExperimentalWithCallbackMethod_attribute_model_load__weight<ExperimentalWithCallbackMethod_attribute_checkpoint_expect__partial<ExperimentalWithCallbackMethod_tensor_op_divide<ExperimentalWithCallbackMethod_iterable_indexing<ExperimentalWithCallbackMethod_byte_tensor_to_numpy<ExperimentalWithCallbackMethod_get_object_by_id<ExperimentalWithCallbackMethod_batch_normalization<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Connect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Connect() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Connect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Connect(::grpc::ServerContext* /*context*/, const ::yolo_tf::ConnectRequest* /*request*/, ::yolo_tf::ConnectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Disconnect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Disconnect() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Disconnect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Disconnect(::grpc::ServerContext* /*context*/, const ::yolo_tf::DisconnectRequest* /*request*/, ::yolo_tf::DisconnectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SayHello : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SayHello() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_SayHello() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SayHello(::grpc::ServerContext* /*context*/, const ::yolo_tf::HelloRequest* /*request*/, ::yolo_tf::HelloReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_callable_emulator : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_callable_emulator() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_callable_emulator() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status callable_emulator(::grpc::ServerContext* /*context*/, const ::yolo_tf::CallRequest* /*request*/, ::yolo_tf::CallResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_iterable_slicing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_iterable_slicing() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_get_iterable_slicing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_iterable_slicing(::grpc::ServerContext* /*context*/, const ::yolo_tf::SlicingRequest* /*request*/, ::yolo_tf::SlicingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_constant : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_constant() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_constant() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status constant(::grpc::ServerContext* /*context*/, const ::yolo_tf::ConstantRequest* /*request*/, ::yolo_tf::ConstantResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_config_experimental_list__physical__devices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_config_experimental_list__physical__devices() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_config_experimental_list__physical__devices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status config_experimental_list__physical__devices(::grpc::ServerContext* /*context*/, const ::yolo_tf::DeviceType* /*request*/, ::yolo_tf::PhysicalDevices* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_image_decode__image : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_image_decode__image() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_image_decode__image() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status image_decode__image(::grpc::ServerContext* /*context*/, const ::yolo_tf::DecodeImageRequest* /*request*/, ::yolo_tf::DecodeImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_expand__dims : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_expand__dims() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_expand__dims() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status expand__dims(::grpc::ServerContext* /*context*/, const ::yolo_tf::ExpandDemensionRequest* /*request*/, ::yolo_tf::ExpandDemensionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_keras_layers_Input : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_keras_layers_Input() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_keras_layers_Input() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_Input(::grpc::ServerContext* /*context*/, const ::yolo_tf::InputRequest* /*request*/, ::yolo_tf::InputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_keras_Model : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_keras_Model() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_keras_Model() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_Model(::grpc::ServerContext* /*context*/, const ::yolo_tf::ModelRequest* /*request*/, ::yolo_tf::ModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_keras_layers_ZeroPadding2D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_keras_layers_ZeroPadding2D() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_keras_layers_ZeroPadding2D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_ZeroPadding2D(::grpc::ServerContext* /*context*/, const ::yolo_tf::ZeroPadding2DRequest* /*request*/, ::yolo_tf::ZeroPadding2DResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_keras_layers_Conv2D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_keras_layers_Conv2D() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_keras_layers_Conv2D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_Conv2D(::grpc::ServerContext* /*context*/, const ::yolo_tf::Conv2DRequest* /*request*/, ::yolo_tf::Conv2DResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_keras_layers_LeakyReLU : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_keras_layers_LeakyReLU() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_keras_layers_LeakyReLU() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_LeakyReLU(::grpc::ServerContext* /*context*/, const ::yolo_tf::LeakyReluRequest* /*request*/, ::yolo_tf::LeakyReluResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_keras_layers_Add : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_keras_layers_Add() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_keras_layers_Add() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_Add(::grpc::ServerContext* /*context*/, const ::yolo_tf::AddRequest* /*request*/, ::yolo_tf::AddResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_keras_layers_Lambda : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_keras_layers_Lambda() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_keras_layers_Lambda() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_Lambda(::grpc::ServerContext* /*context*/, const ::yolo_tf::LambdaRequest* /*request*/, ::yolo_tf::LambdaResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_keras_layers_UpSampling2D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_keras_layers_UpSampling2D() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_keras_layers_UpSampling2D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_UpSampling2D(::grpc::ServerContext* /*context*/, const ::yolo_tf::UpSampling2DRequest* /*request*/, ::yolo_tf::UpSampling2DResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_keras_layers_Concatenate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_keras_layers_Concatenate() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_keras_layers_Concatenate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_Concatenate(::grpc::ServerContext* /*context*/, const ::yolo_tf::ConcatenateRequest* /*request*/, ::yolo_tf::ContcatenateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_image_resize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_image_resize() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_image_resize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status image_resize(::grpc::ServerContext* /*context*/, const ::yolo_tf::ImageResizeRequest* /*request*/, ::yolo_tf::ImageResizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_keras_regularizers_l2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_keras_regularizers_l2() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_keras_regularizers_l2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_regularizers_l2(::grpc::ServerContext* /*context*/, const ::yolo_tf::l2Request* /*request*/, ::yolo_tf::l2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_attribute_tensor_shape : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_attribute_tensor_shape() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_attribute_tensor_shape() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status attribute_tensor_shape(::grpc::ServerContext* /*context*/, const ::yolo_tf::TensorShapeRequest* /*request*/, ::yolo_tf::TensorShapeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_attribute_model_load__weight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_attribute_model_load__weight() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_attribute_model_load__weight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status attribute_model_load__weight(::grpc::ServerContext* /*context*/, const ::yolo_tf::LoadWeightsRequest* /*request*/, ::yolo_tf::LoadWeightsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_attribute_checkpoint_expect__partial : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_attribute_checkpoint_expect__partial() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_attribute_checkpoint_expect__partial() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status attribute_checkpoint_expect__partial(::grpc::ServerContext* /*context*/, const ::yolo_tf::ExpectPartialRequest* /*request*/, ::yolo_tf::ExpectPartialResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_tensor_op_divide : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_tensor_op_divide() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_tensor_op_divide() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status tensor_op_divide(::grpc::ServerContext* /*context*/, const ::yolo_tf::DivideRequest* /*request*/, ::yolo_tf::DivideResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_iterable_indexing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_iterable_indexing() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_iterable_indexing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status iterable_indexing(::grpc::ServerContext* /*context*/, const ::yolo_tf::IndexingRequest* /*request*/, ::yolo_tf::IndexingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_byte_tensor_to_numpy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_byte_tensor_to_numpy() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_byte_tensor_to_numpy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status byte_tensor_to_numpy(::grpc::ServerContext* /*context*/, const ::yolo_tf::TensorToNumpyRequest* /*request*/, ::yolo_tf::TensorToNumPyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_object_by_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_object_by_id() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_get_object_by_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_object_by_id(::grpc::ServerContext* /*context*/, const ::yolo_tf::GetObjectRequest* /*request*/, ::yolo_tf::GetObjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_batch_normalization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_batch_normalization() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_batch_normalization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status batch_normalization(::grpc::ServerContext* /*context*/, const ::yolo_tf::BatchNormRequest* /*request*/, ::yolo_tf::BatchNormResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Connect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Connect() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Connect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Connect(::grpc::ServerContext* /*context*/, const ::yolo_tf::ConnectRequest* /*request*/, ::yolo_tf::ConnectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConnect(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Disconnect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Disconnect() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Disconnect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Disconnect(::grpc::ServerContext* /*context*/, const ::yolo_tf::DisconnectRequest* /*request*/, ::yolo_tf::DisconnectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisconnect(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SayHello : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SayHello() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_SayHello() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SayHello(::grpc::ServerContext* /*context*/, const ::yolo_tf::HelloRequest* /*request*/, ::yolo_tf::HelloReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSayHello(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_callable_emulator : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_callable_emulator() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_callable_emulator() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status callable_emulator(::grpc::ServerContext* /*context*/, const ::yolo_tf::CallRequest* /*request*/, ::yolo_tf::CallResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcallable_emulator(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_iterable_slicing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_iterable_slicing() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_get_iterable_slicing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_iterable_slicing(::grpc::ServerContext* /*context*/, const ::yolo_tf::SlicingRequest* /*request*/, ::yolo_tf::SlicingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_iterable_slicing(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_constant : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_constant() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_constant() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status constant(::grpc::ServerContext* /*context*/, const ::yolo_tf::ConstantRequest* /*request*/, ::yolo_tf::ConstantResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestconstant(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_config_experimental_list__physical__devices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_config_experimental_list__physical__devices() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_config_experimental_list__physical__devices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status config_experimental_list__physical__devices(::grpc::ServerContext* /*context*/, const ::yolo_tf::DeviceType* /*request*/, ::yolo_tf::PhysicalDevices* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestconfig_experimental_list__physical__devices(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_image_decode__image : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_image_decode__image() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_image_decode__image() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status image_decode__image(::grpc::ServerContext* /*context*/, const ::yolo_tf::DecodeImageRequest* /*request*/, ::yolo_tf::DecodeImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestimage_decode__image(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_expand__dims : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_expand__dims() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_expand__dims() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status expand__dims(::grpc::ServerContext* /*context*/, const ::yolo_tf::ExpandDemensionRequest* /*request*/, ::yolo_tf::ExpandDemensionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestexpand__dims(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_keras_layers_Input : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_keras_layers_Input() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_keras_layers_Input() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_Input(::grpc::ServerContext* /*context*/, const ::yolo_tf::InputRequest* /*request*/, ::yolo_tf::InputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestkeras_layers_Input(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_keras_Model : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_keras_Model() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_keras_Model() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_Model(::grpc::ServerContext* /*context*/, const ::yolo_tf::ModelRequest* /*request*/, ::yolo_tf::ModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestkeras_Model(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_keras_layers_ZeroPadding2D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_keras_layers_ZeroPadding2D() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_keras_layers_ZeroPadding2D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_ZeroPadding2D(::grpc::ServerContext* /*context*/, const ::yolo_tf::ZeroPadding2DRequest* /*request*/, ::yolo_tf::ZeroPadding2DResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestkeras_layers_ZeroPadding2D(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_keras_layers_Conv2D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_keras_layers_Conv2D() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_keras_layers_Conv2D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_Conv2D(::grpc::ServerContext* /*context*/, const ::yolo_tf::Conv2DRequest* /*request*/, ::yolo_tf::Conv2DResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestkeras_layers_Conv2D(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_keras_layers_LeakyReLU : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_keras_layers_LeakyReLU() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_keras_layers_LeakyReLU() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_LeakyReLU(::grpc::ServerContext* /*context*/, const ::yolo_tf::LeakyReluRequest* /*request*/, ::yolo_tf::LeakyReluResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestkeras_layers_LeakyReLU(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_keras_layers_Add : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_keras_layers_Add() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_keras_layers_Add() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_Add(::grpc::ServerContext* /*context*/, const ::yolo_tf::AddRequest* /*request*/, ::yolo_tf::AddResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestkeras_layers_Add(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_keras_layers_Lambda : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_keras_layers_Lambda() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_keras_layers_Lambda() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_Lambda(::grpc::ServerContext* /*context*/, const ::yolo_tf::LambdaRequest* /*request*/, ::yolo_tf::LambdaResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestkeras_layers_Lambda(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_keras_layers_UpSampling2D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_keras_layers_UpSampling2D() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_keras_layers_UpSampling2D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_UpSampling2D(::grpc::ServerContext* /*context*/, const ::yolo_tf::UpSampling2DRequest* /*request*/, ::yolo_tf::UpSampling2DResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestkeras_layers_UpSampling2D(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_keras_layers_Concatenate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_keras_layers_Concatenate() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_keras_layers_Concatenate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_Concatenate(::grpc::ServerContext* /*context*/, const ::yolo_tf::ConcatenateRequest* /*request*/, ::yolo_tf::ContcatenateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestkeras_layers_Concatenate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_image_resize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_image_resize() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_image_resize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status image_resize(::grpc::ServerContext* /*context*/, const ::yolo_tf::ImageResizeRequest* /*request*/, ::yolo_tf::ImageResizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestimage_resize(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_keras_regularizers_l2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_keras_regularizers_l2() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_keras_regularizers_l2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_regularizers_l2(::grpc::ServerContext* /*context*/, const ::yolo_tf::l2Request* /*request*/, ::yolo_tf::l2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestkeras_regularizers_l2(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_attribute_tensor_shape : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_attribute_tensor_shape() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_attribute_tensor_shape() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status attribute_tensor_shape(::grpc::ServerContext* /*context*/, const ::yolo_tf::TensorShapeRequest* /*request*/, ::yolo_tf::TensorShapeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestattribute_tensor_shape(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_attribute_model_load__weight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_attribute_model_load__weight() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_attribute_model_load__weight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status attribute_model_load__weight(::grpc::ServerContext* /*context*/, const ::yolo_tf::LoadWeightsRequest* /*request*/, ::yolo_tf::LoadWeightsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestattribute_model_load__weight(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_attribute_checkpoint_expect__partial : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_attribute_checkpoint_expect__partial() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_attribute_checkpoint_expect__partial() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status attribute_checkpoint_expect__partial(::grpc::ServerContext* /*context*/, const ::yolo_tf::ExpectPartialRequest* /*request*/, ::yolo_tf::ExpectPartialResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestattribute_checkpoint_expect__partial(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_tensor_op_divide : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_tensor_op_divide() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_tensor_op_divide() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status tensor_op_divide(::grpc::ServerContext* /*context*/, const ::yolo_tf::DivideRequest* /*request*/, ::yolo_tf::DivideResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesttensor_op_divide(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_iterable_indexing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_iterable_indexing() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_iterable_indexing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status iterable_indexing(::grpc::ServerContext* /*context*/, const ::yolo_tf::IndexingRequest* /*request*/, ::yolo_tf::IndexingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestiterable_indexing(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_byte_tensor_to_numpy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_byte_tensor_to_numpy() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_byte_tensor_to_numpy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status byte_tensor_to_numpy(::grpc::ServerContext* /*context*/, const ::yolo_tf::TensorToNumpyRequest* /*request*/, ::yolo_tf::TensorToNumPyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestbyte_tensor_to_numpy(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_object_by_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_object_by_id() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_get_object_by_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_object_by_id(::grpc::ServerContext* /*context*/, const ::yolo_tf::GetObjectRequest* /*request*/, ::yolo_tf::GetObjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_object_by_id(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_batch_normalization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_batch_normalization() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_batch_normalization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status batch_normalization(::grpc::ServerContext* /*context*/, const ::yolo_tf::BatchNormRequest* /*request*/, ::yolo_tf::BatchNormResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestbatch_normalization(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Connect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Connect() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Connect(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Connect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Connect(::grpc::ServerContext* /*context*/, const ::yolo_tf::ConnectRequest* /*request*/, ::yolo_tf::ConnectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Connect(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Connect(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Disconnect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Disconnect() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Disconnect(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Disconnect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Disconnect(::grpc::ServerContext* /*context*/, const ::yolo_tf::DisconnectRequest* /*request*/, ::yolo_tf::DisconnectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Disconnect(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Disconnect(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SayHello : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SayHello() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SayHello(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SayHello() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SayHello(::grpc::ServerContext* /*context*/, const ::yolo_tf::HelloRequest* /*request*/, ::yolo_tf::HelloReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SayHello(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SayHello(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_callable_emulator : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_callable_emulator() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->callable_emulator(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_callable_emulator() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status callable_emulator(::grpc::ServerContext* /*context*/, const ::yolo_tf::CallRequest* /*request*/, ::yolo_tf::CallResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* callable_emulator(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* callable_emulator(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_get_iterable_slicing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_get_iterable_slicing() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_iterable_slicing(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_get_iterable_slicing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_iterable_slicing(::grpc::ServerContext* /*context*/, const ::yolo_tf::SlicingRequest* /*request*/, ::yolo_tf::SlicingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_iterable_slicing(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_iterable_slicing(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_constant : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_constant() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->constant(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_constant() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status constant(::grpc::ServerContext* /*context*/, const ::yolo_tf::ConstantRequest* /*request*/, ::yolo_tf::ConstantResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* constant(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* constant(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_config_experimental_list__physical__devices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_config_experimental_list__physical__devices() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->config_experimental_list__physical__devices(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_config_experimental_list__physical__devices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status config_experimental_list__physical__devices(::grpc::ServerContext* /*context*/, const ::yolo_tf::DeviceType* /*request*/, ::yolo_tf::PhysicalDevices* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* config_experimental_list__physical__devices(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* config_experimental_list__physical__devices(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_image_decode__image : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_image_decode__image() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->image_decode__image(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_image_decode__image() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status image_decode__image(::grpc::ServerContext* /*context*/, const ::yolo_tf::DecodeImageRequest* /*request*/, ::yolo_tf::DecodeImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* image_decode__image(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* image_decode__image(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_expand__dims : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_expand__dims() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->expand__dims(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_expand__dims() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status expand__dims(::grpc::ServerContext* /*context*/, const ::yolo_tf::ExpandDemensionRequest* /*request*/, ::yolo_tf::ExpandDemensionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* expand__dims(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* expand__dims(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_keras_layers_Input : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_keras_layers_Input() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->keras_layers_Input(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_keras_layers_Input() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_Input(::grpc::ServerContext* /*context*/, const ::yolo_tf::InputRequest* /*request*/, ::yolo_tf::InputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* keras_layers_Input(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* keras_layers_Input(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_keras_Model : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_keras_Model() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->keras_Model(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_keras_Model() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_Model(::grpc::ServerContext* /*context*/, const ::yolo_tf::ModelRequest* /*request*/, ::yolo_tf::ModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* keras_Model(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* keras_Model(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_keras_layers_ZeroPadding2D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_keras_layers_ZeroPadding2D() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->keras_layers_ZeroPadding2D(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_keras_layers_ZeroPadding2D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_ZeroPadding2D(::grpc::ServerContext* /*context*/, const ::yolo_tf::ZeroPadding2DRequest* /*request*/, ::yolo_tf::ZeroPadding2DResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* keras_layers_ZeroPadding2D(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* keras_layers_ZeroPadding2D(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_keras_layers_Conv2D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_keras_layers_Conv2D() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->keras_layers_Conv2D(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_keras_layers_Conv2D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_Conv2D(::grpc::ServerContext* /*context*/, const ::yolo_tf::Conv2DRequest* /*request*/, ::yolo_tf::Conv2DResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* keras_layers_Conv2D(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* keras_layers_Conv2D(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_keras_layers_LeakyReLU : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_keras_layers_LeakyReLU() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->keras_layers_LeakyReLU(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_keras_layers_LeakyReLU() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_LeakyReLU(::grpc::ServerContext* /*context*/, const ::yolo_tf::LeakyReluRequest* /*request*/, ::yolo_tf::LeakyReluResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* keras_layers_LeakyReLU(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* keras_layers_LeakyReLU(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_keras_layers_Add : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_keras_layers_Add() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(14,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->keras_layers_Add(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_keras_layers_Add() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_Add(::grpc::ServerContext* /*context*/, const ::yolo_tf::AddRequest* /*request*/, ::yolo_tf::AddResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* keras_layers_Add(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* keras_layers_Add(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_keras_layers_Lambda : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_keras_layers_Lambda() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(15,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->keras_layers_Lambda(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_keras_layers_Lambda() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_Lambda(::grpc::ServerContext* /*context*/, const ::yolo_tf::LambdaRequest* /*request*/, ::yolo_tf::LambdaResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* keras_layers_Lambda(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* keras_layers_Lambda(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_keras_layers_UpSampling2D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_keras_layers_UpSampling2D() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(16,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->keras_layers_UpSampling2D(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_keras_layers_UpSampling2D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_UpSampling2D(::grpc::ServerContext* /*context*/, const ::yolo_tf::UpSampling2DRequest* /*request*/, ::yolo_tf::UpSampling2DResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* keras_layers_UpSampling2D(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* keras_layers_UpSampling2D(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_keras_layers_Concatenate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_keras_layers_Concatenate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(17,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->keras_layers_Concatenate(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_keras_layers_Concatenate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_layers_Concatenate(::grpc::ServerContext* /*context*/, const ::yolo_tf::ConcatenateRequest* /*request*/, ::yolo_tf::ContcatenateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* keras_layers_Concatenate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* keras_layers_Concatenate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_image_resize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_image_resize() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(18,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->image_resize(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_image_resize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status image_resize(::grpc::ServerContext* /*context*/, const ::yolo_tf::ImageResizeRequest* /*request*/, ::yolo_tf::ImageResizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* image_resize(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* image_resize(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_keras_regularizers_l2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_keras_regularizers_l2() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(19,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->keras_regularizers_l2(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_keras_regularizers_l2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keras_regularizers_l2(::grpc::ServerContext* /*context*/, const ::yolo_tf::l2Request* /*request*/, ::yolo_tf::l2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* keras_regularizers_l2(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* keras_regularizers_l2(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_attribute_tensor_shape : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_attribute_tensor_shape() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(20,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->attribute_tensor_shape(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_attribute_tensor_shape() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status attribute_tensor_shape(::grpc::ServerContext* /*context*/, const ::yolo_tf::TensorShapeRequest* /*request*/, ::yolo_tf::TensorShapeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* attribute_tensor_shape(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* attribute_tensor_shape(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_attribute_model_load__weight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_attribute_model_load__weight() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(21,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->attribute_model_load__weight(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_attribute_model_load__weight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status attribute_model_load__weight(::grpc::ServerContext* /*context*/, const ::yolo_tf::LoadWeightsRequest* /*request*/, ::yolo_tf::LoadWeightsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* attribute_model_load__weight(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* attribute_model_load__weight(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_attribute_checkpoint_expect__partial : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_attribute_checkpoint_expect__partial() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(22,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->attribute_checkpoint_expect__partial(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_attribute_checkpoint_expect__partial() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status attribute_checkpoint_expect__partial(::grpc::ServerContext* /*context*/, const ::yolo_tf::ExpectPartialRequest* /*request*/, ::yolo_tf::ExpectPartialResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* attribute_checkpoint_expect__partial(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* attribute_checkpoint_expect__partial(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_tensor_op_divide : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_tensor_op_divide() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(23,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->tensor_op_divide(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_tensor_op_divide() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status tensor_op_divide(::grpc::ServerContext* /*context*/, const ::yolo_tf::DivideRequest* /*request*/, ::yolo_tf::DivideResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* tensor_op_divide(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* tensor_op_divide(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_iterable_indexing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_iterable_indexing() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(24,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->iterable_indexing(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_iterable_indexing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status iterable_indexing(::grpc::ServerContext* /*context*/, const ::yolo_tf::IndexingRequest* /*request*/, ::yolo_tf::IndexingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* iterable_indexing(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* iterable_indexing(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_byte_tensor_to_numpy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_byte_tensor_to_numpy() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(25,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->byte_tensor_to_numpy(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_byte_tensor_to_numpy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status byte_tensor_to_numpy(::grpc::ServerContext* /*context*/, const ::yolo_tf::TensorToNumpyRequest* /*request*/, ::yolo_tf::TensorToNumPyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* byte_tensor_to_numpy(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* byte_tensor_to_numpy(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_get_object_by_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_get_object_by_id() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(26,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_object_by_id(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_get_object_by_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_object_by_id(::grpc::ServerContext* /*context*/, const ::yolo_tf::GetObjectRequest* /*request*/, ::yolo_tf::GetObjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* get_object_by_id(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* get_object_by_id(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_batch_normalization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_batch_normalization() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(27,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->batch_normalization(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_batch_normalization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status batch_normalization(::grpc::ServerContext* /*context*/, const ::yolo_tf::BatchNormRequest* /*request*/, ::yolo_tf::BatchNormResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* batch_normalization(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* batch_normalization(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Connect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Connect() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::ConnectRequest, ::yolo_tf::ConnectResponse>(std::bind(&WithStreamedUnaryMethod_Connect<BaseClass>::StreamedConnect, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Connect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Connect(::grpc::ServerContext* /*context*/, const ::yolo_tf::ConnectRequest* /*request*/, ::yolo_tf::ConnectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedConnect(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::ConnectRequest,::yolo_tf::ConnectResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Disconnect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Disconnect() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::DisconnectRequest, ::yolo_tf::DisconnectResponse>(std::bind(&WithStreamedUnaryMethod_Disconnect<BaseClass>::StreamedDisconnect, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Disconnect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Disconnect(::grpc::ServerContext* /*context*/, const ::yolo_tf::DisconnectRequest* /*request*/, ::yolo_tf::DisconnectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDisconnect(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::DisconnectRequest,::yolo_tf::DisconnectResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SayHello : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SayHello() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::HelloRequest, ::yolo_tf::HelloReply>(std::bind(&WithStreamedUnaryMethod_SayHello<BaseClass>::StreamedSayHello, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_SayHello() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SayHello(::grpc::ServerContext* /*context*/, const ::yolo_tf::HelloRequest* /*request*/, ::yolo_tf::HelloReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSayHello(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::HelloRequest,::yolo_tf::HelloReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_callable_emulator : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_callable_emulator() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::CallRequest, ::yolo_tf::CallResponse>(std::bind(&WithStreamedUnaryMethod_callable_emulator<BaseClass>::Streamedcallable_emulator, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_callable_emulator() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status callable_emulator(::grpc::ServerContext* /*context*/, const ::yolo_tf::CallRequest* /*request*/, ::yolo_tf::CallResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedcallable_emulator(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::CallRequest,::yolo_tf::CallResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_iterable_slicing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_iterable_slicing() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::SlicingRequest, ::yolo_tf::SlicingResponse>(std::bind(&WithStreamedUnaryMethod_get_iterable_slicing<BaseClass>::Streamedget_iterable_slicing, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_get_iterable_slicing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_iterable_slicing(::grpc::ServerContext* /*context*/, const ::yolo_tf::SlicingRequest* /*request*/, ::yolo_tf::SlicingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_iterable_slicing(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::SlicingRequest,::yolo_tf::SlicingResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_constant : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_constant() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::ConstantRequest, ::yolo_tf::ConstantResponse>(std::bind(&WithStreamedUnaryMethod_constant<BaseClass>::Streamedconstant, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_constant() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status constant(::grpc::ServerContext* /*context*/, const ::yolo_tf::ConstantRequest* /*request*/, ::yolo_tf::ConstantResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedconstant(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::ConstantRequest,::yolo_tf::ConstantResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_config_experimental_list__physical__devices : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_config_experimental_list__physical__devices() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::DeviceType, ::yolo_tf::PhysicalDevices>(std::bind(&WithStreamedUnaryMethod_config_experimental_list__physical__devices<BaseClass>::Streamedconfig_experimental_list__physical__devices, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_config_experimental_list__physical__devices() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status config_experimental_list__physical__devices(::grpc::ServerContext* /*context*/, const ::yolo_tf::DeviceType* /*request*/, ::yolo_tf::PhysicalDevices* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedconfig_experimental_list__physical__devices(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::DeviceType,::yolo_tf::PhysicalDevices>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_image_decode__image : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_image_decode__image() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::DecodeImageRequest, ::yolo_tf::DecodeImageResponse>(std::bind(&WithStreamedUnaryMethod_image_decode__image<BaseClass>::Streamedimage_decode__image, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_image_decode__image() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status image_decode__image(::grpc::ServerContext* /*context*/, const ::yolo_tf::DecodeImageRequest* /*request*/, ::yolo_tf::DecodeImageResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedimage_decode__image(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::DecodeImageRequest,::yolo_tf::DecodeImageResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_expand__dims : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_expand__dims() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::ExpandDemensionRequest, ::yolo_tf::ExpandDemensionResponse>(std::bind(&WithStreamedUnaryMethod_expand__dims<BaseClass>::Streamedexpand__dims, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_expand__dims() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status expand__dims(::grpc::ServerContext* /*context*/, const ::yolo_tf::ExpandDemensionRequest* /*request*/, ::yolo_tf::ExpandDemensionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedexpand__dims(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::ExpandDemensionRequest,::yolo_tf::ExpandDemensionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_keras_layers_Input : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_keras_layers_Input() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::InputRequest, ::yolo_tf::InputResponse>(std::bind(&WithStreamedUnaryMethod_keras_layers_Input<BaseClass>::Streamedkeras_layers_Input, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_keras_layers_Input() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status keras_layers_Input(::grpc::ServerContext* /*context*/, const ::yolo_tf::InputRequest* /*request*/, ::yolo_tf::InputResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedkeras_layers_Input(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::InputRequest,::yolo_tf::InputResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_keras_Model : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_keras_Model() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::ModelRequest, ::yolo_tf::ModelResponse>(std::bind(&WithStreamedUnaryMethod_keras_Model<BaseClass>::Streamedkeras_Model, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_keras_Model() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status keras_Model(::grpc::ServerContext* /*context*/, const ::yolo_tf::ModelRequest* /*request*/, ::yolo_tf::ModelResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedkeras_Model(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::ModelRequest,::yolo_tf::ModelResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_keras_layers_ZeroPadding2D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_keras_layers_ZeroPadding2D() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::ZeroPadding2DRequest, ::yolo_tf::ZeroPadding2DResponse>(std::bind(&WithStreamedUnaryMethod_keras_layers_ZeroPadding2D<BaseClass>::Streamedkeras_layers_ZeroPadding2D, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_keras_layers_ZeroPadding2D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status keras_layers_ZeroPadding2D(::grpc::ServerContext* /*context*/, const ::yolo_tf::ZeroPadding2DRequest* /*request*/, ::yolo_tf::ZeroPadding2DResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedkeras_layers_ZeroPadding2D(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::ZeroPadding2DRequest,::yolo_tf::ZeroPadding2DResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_keras_layers_Conv2D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_keras_layers_Conv2D() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::Conv2DRequest, ::yolo_tf::Conv2DResponse>(std::bind(&WithStreamedUnaryMethod_keras_layers_Conv2D<BaseClass>::Streamedkeras_layers_Conv2D, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_keras_layers_Conv2D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status keras_layers_Conv2D(::grpc::ServerContext* /*context*/, const ::yolo_tf::Conv2DRequest* /*request*/, ::yolo_tf::Conv2DResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedkeras_layers_Conv2D(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::Conv2DRequest,::yolo_tf::Conv2DResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_keras_layers_LeakyReLU : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_keras_layers_LeakyReLU() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::LeakyReluRequest, ::yolo_tf::LeakyReluResponse>(std::bind(&WithStreamedUnaryMethod_keras_layers_LeakyReLU<BaseClass>::Streamedkeras_layers_LeakyReLU, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_keras_layers_LeakyReLU() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status keras_layers_LeakyReLU(::grpc::ServerContext* /*context*/, const ::yolo_tf::LeakyReluRequest* /*request*/, ::yolo_tf::LeakyReluResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedkeras_layers_LeakyReLU(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::LeakyReluRequest,::yolo_tf::LeakyReluResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_keras_layers_Add : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_keras_layers_Add() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::AddRequest, ::yolo_tf::AddResponse>(std::bind(&WithStreamedUnaryMethod_keras_layers_Add<BaseClass>::Streamedkeras_layers_Add, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_keras_layers_Add() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status keras_layers_Add(::grpc::ServerContext* /*context*/, const ::yolo_tf::AddRequest* /*request*/, ::yolo_tf::AddResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedkeras_layers_Add(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::AddRequest,::yolo_tf::AddResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_keras_layers_Lambda : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_keras_layers_Lambda() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::LambdaRequest, ::yolo_tf::LambdaResponse>(std::bind(&WithStreamedUnaryMethod_keras_layers_Lambda<BaseClass>::Streamedkeras_layers_Lambda, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_keras_layers_Lambda() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status keras_layers_Lambda(::grpc::ServerContext* /*context*/, const ::yolo_tf::LambdaRequest* /*request*/, ::yolo_tf::LambdaResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedkeras_layers_Lambda(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::LambdaRequest,::yolo_tf::LambdaResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_keras_layers_UpSampling2D : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_keras_layers_UpSampling2D() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::UpSampling2DRequest, ::yolo_tf::UpSampling2DResponse>(std::bind(&WithStreamedUnaryMethod_keras_layers_UpSampling2D<BaseClass>::Streamedkeras_layers_UpSampling2D, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_keras_layers_UpSampling2D() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status keras_layers_UpSampling2D(::grpc::ServerContext* /*context*/, const ::yolo_tf::UpSampling2DRequest* /*request*/, ::yolo_tf::UpSampling2DResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedkeras_layers_UpSampling2D(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::UpSampling2DRequest,::yolo_tf::UpSampling2DResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_keras_layers_Concatenate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_keras_layers_Concatenate() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::ConcatenateRequest, ::yolo_tf::ContcatenateResponse>(std::bind(&WithStreamedUnaryMethod_keras_layers_Concatenate<BaseClass>::Streamedkeras_layers_Concatenate, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_keras_layers_Concatenate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status keras_layers_Concatenate(::grpc::ServerContext* /*context*/, const ::yolo_tf::ConcatenateRequest* /*request*/, ::yolo_tf::ContcatenateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedkeras_layers_Concatenate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::ConcatenateRequest,::yolo_tf::ContcatenateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_image_resize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_image_resize() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::ImageResizeRequest, ::yolo_tf::ImageResizeResponse>(std::bind(&WithStreamedUnaryMethod_image_resize<BaseClass>::Streamedimage_resize, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_image_resize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status image_resize(::grpc::ServerContext* /*context*/, const ::yolo_tf::ImageResizeRequest* /*request*/, ::yolo_tf::ImageResizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedimage_resize(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::ImageResizeRequest,::yolo_tf::ImageResizeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_keras_regularizers_l2 : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_keras_regularizers_l2() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::l2Request, ::yolo_tf::l2Response>(std::bind(&WithStreamedUnaryMethod_keras_regularizers_l2<BaseClass>::Streamedkeras_regularizers_l2, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_keras_regularizers_l2() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status keras_regularizers_l2(::grpc::ServerContext* /*context*/, const ::yolo_tf::l2Request* /*request*/, ::yolo_tf::l2Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedkeras_regularizers_l2(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::l2Request,::yolo_tf::l2Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_attribute_tensor_shape : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_attribute_tensor_shape() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::TensorShapeRequest, ::yolo_tf::TensorShapeResponse>(std::bind(&WithStreamedUnaryMethod_attribute_tensor_shape<BaseClass>::Streamedattribute_tensor_shape, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_attribute_tensor_shape() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status attribute_tensor_shape(::grpc::ServerContext* /*context*/, const ::yolo_tf::TensorShapeRequest* /*request*/, ::yolo_tf::TensorShapeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedattribute_tensor_shape(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::TensorShapeRequest,::yolo_tf::TensorShapeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_attribute_model_load__weight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_attribute_model_load__weight() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::LoadWeightsRequest, ::yolo_tf::LoadWeightsResponse>(std::bind(&WithStreamedUnaryMethod_attribute_model_load__weight<BaseClass>::Streamedattribute_model_load__weight, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_attribute_model_load__weight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status attribute_model_load__weight(::grpc::ServerContext* /*context*/, const ::yolo_tf::LoadWeightsRequest* /*request*/, ::yolo_tf::LoadWeightsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedattribute_model_load__weight(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::LoadWeightsRequest,::yolo_tf::LoadWeightsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_attribute_checkpoint_expect__partial : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_attribute_checkpoint_expect__partial() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::ExpectPartialRequest, ::yolo_tf::ExpectPartialResponse>(std::bind(&WithStreamedUnaryMethod_attribute_checkpoint_expect__partial<BaseClass>::Streamedattribute_checkpoint_expect__partial, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_attribute_checkpoint_expect__partial() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status attribute_checkpoint_expect__partial(::grpc::ServerContext* /*context*/, const ::yolo_tf::ExpectPartialRequest* /*request*/, ::yolo_tf::ExpectPartialResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedattribute_checkpoint_expect__partial(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::ExpectPartialRequest,::yolo_tf::ExpectPartialResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_tensor_op_divide : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_tensor_op_divide() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::DivideRequest, ::yolo_tf::DivideResponse>(std::bind(&WithStreamedUnaryMethod_tensor_op_divide<BaseClass>::Streamedtensor_op_divide, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_tensor_op_divide() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status tensor_op_divide(::grpc::ServerContext* /*context*/, const ::yolo_tf::DivideRequest* /*request*/, ::yolo_tf::DivideResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedtensor_op_divide(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::DivideRequest,::yolo_tf::DivideResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_iterable_indexing : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_iterable_indexing() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::IndexingRequest, ::yolo_tf::IndexingResponse>(std::bind(&WithStreamedUnaryMethod_iterable_indexing<BaseClass>::Streamediterable_indexing, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_iterable_indexing() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status iterable_indexing(::grpc::ServerContext* /*context*/, const ::yolo_tf::IndexingRequest* /*request*/, ::yolo_tf::IndexingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamediterable_indexing(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::IndexingRequest,::yolo_tf::IndexingResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_byte_tensor_to_numpy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_byte_tensor_to_numpy() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::TensorToNumpyRequest, ::yolo_tf::TensorToNumPyResponse>(std::bind(&WithStreamedUnaryMethod_byte_tensor_to_numpy<BaseClass>::Streamedbyte_tensor_to_numpy, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_byte_tensor_to_numpy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status byte_tensor_to_numpy(::grpc::ServerContext* /*context*/, const ::yolo_tf::TensorToNumpyRequest* /*request*/, ::yolo_tf::TensorToNumPyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedbyte_tensor_to_numpy(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::TensorToNumpyRequest,::yolo_tf::TensorToNumPyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_object_by_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_object_by_id() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::GetObjectRequest, ::yolo_tf::GetObjectResponse>(std::bind(&WithStreamedUnaryMethod_get_object_by_id<BaseClass>::Streamedget_object_by_id, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_get_object_by_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_object_by_id(::grpc::ServerContext* /*context*/, const ::yolo_tf::GetObjectRequest* /*request*/, ::yolo_tf::GetObjectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_object_by_id(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::GetObjectRequest,::yolo_tf::GetObjectResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_batch_normalization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_batch_normalization() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler< ::yolo_tf::BatchNormRequest, ::yolo_tf::BatchNormResponse>(std::bind(&WithStreamedUnaryMethod_batch_normalization<BaseClass>::Streamedbatch_normalization, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_batch_normalization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status batch_normalization(::grpc::ServerContext* /*context*/, const ::yolo_tf::BatchNormRequest* /*request*/, ::yolo_tf::BatchNormResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedbatch_normalization(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::yolo_tf::BatchNormRequest,::yolo_tf::BatchNormResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Connect<WithStreamedUnaryMethod_Disconnect<WithStreamedUnaryMethod_SayHello<WithStreamedUnaryMethod_callable_emulator<WithStreamedUnaryMethod_get_iterable_slicing<WithStreamedUnaryMethod_constant<WithStreamedUnaryMethod_config_experimental_list__physical__devices<WithStreamedUnaryMethod_image_decode__image<WithStreamedUnaryMethod_expand__dims<WithStreamedUnaryMethod_keras_layers_Input<WithStreamedUnaryMethod_keras_Model<WithStreamedUnaryMethod_keras_layers_ZeroPadding2D<WithStreamedUnaryMethod_keras_layers_Conv2D<WithStreamedUnaryMethod_keras_layers_LeakyReLU<WithStreamedUnaryMethod_keras_layers_Add<WithStreamedUnaryMethod_keras_layers_Lambda<WithStreamedUnaryMethod_keras_layers_UpSampling2D<WithStreamedUnaryMethod_keras_layers_Concatenate<WithStreamedUnaryMethod_image_resize<WithStreamedUnaryMethod_keras_regularizers_l2<WithStreamedUnaryMethod_attribute_tensor_shape<WithStreamedUnaryMethod_attribute_model_load__weight<WithStreamedUnaryMethod_attribute_checkpoint_expect__partial<WithStreamedUnaryMethod_tensor_op_divide<WithStreamedUnaryMethod_iterable_indexing<WithStreamedUnaryMethod_byte_tensor_to_numpy<WithStreamedUnaryMethod_get_object_by_id<WithStreamedUnaryMethod_batch_normalization<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Connect<WithStreamedUnaryMethod_Disconnect<WithStreamedUnaryMethod_SayHello<WithStreamedUnaryMethod_callable_emulator<WithStreamedUnaryMethod_get_iterable_slicing<WithStreamedUnaryMethod_constant<WithStreamedUnaryMethod_config_experimental_list__physical__devices<WithStreamedUnaryMethod_image_decode__image<WithStreamedUnaryMethod_expand__dims<WithStreamedUnaryMethod_keras_layers_Input<WithStreamedUnaryMethod_keras_Model<WithStreamedUnaryMethod_keras_layers_ZeroPadding2D<WithStreamedUnaryMethod_keras_layers_Conv2D<WithStreamedUnaryMethod_keras_layers_LeakyReLU<WithStreamedUnaryMethod_keras_layers_Add<WithStreamedUnaryMethod_keras_layers_Lambda<WithStreamedUnaryMethod_keras_layers_UpSampling2D<WithStreamedUnaryMethod_keras_layers_Concatenate<WithStreamedUnaryMethod_image_resize<WithStreamedUnaryMethod_keras_regularizers_l2<WithStreamedUnaryMethod_attribute_tensor_shape<WithStreamedUnaryMethod_attribute_model_load__weight<WithStreamedUnaryMethod_attribute_checkpoint_expect__partial<WithStreamedUnaryMethod_tensor_op_divide<WithStreamedUnaryMethod_iterable_indexing<WithStreamedUnaryMethod_byte_tensor_to_numpy<WithStreamedUnaryMethod_get_object_by_id<WithStreamedUnaryMethod_batch_normalization<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace yolo_tf


#endif  // GRPC_yolo_2eproto__INCLUDED
