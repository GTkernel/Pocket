// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: yolo.proto

#include "yolo.pb.h"
#include "yolo.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace yolo_tf {

static const char* YoloTensorflowWrapper_method_names[] = {
  "/yolo_tf.YoloTensorflowWrapper/Connect",
  "/yolo_tf.YoloTensorflowWrapper/Disconnect",
  "/yolo_tf.YoloTensorflowWrapper/SayHello",
  "/yolo_tf.YoloTensorflowWrapper/callable_emulator",
  "/yolo_tf.YoloTensorflowWrapper/get_iterable_slicing",
  "/yolo_tf.YoloTensorflowWrapper/constant",
  "/yolo_tf.YoloTensorflowWrapper/config_experimental_list__physical__devices",
  "/yolo_tf.YoloTensorflowWrapper/image_decode__image",
  "/yolo_tf.YoloTensorflowWrapper/expand__dims",
  "/yolo_tf.YoloTensorflowWrapper/keras_layers_Input",
  "/yolo_tf.YoloTensorflowWrapper/keras_Model",
  "/yolo_tf.YoloTensorflowWrapper/keras_layers_ZeroPadding2D",
  "/yolo_tf.YoloTensorflowWrapper/keras_layers_Conv2D",
  "/yolo_tf.YoloTensorflowWrapper/keras_layers_LeakyReLU",
  "/yolo_tf.YoloTensorflowWrapper/keras_layers_Add",
  "/yolo_tf.YoloTensorflowWrapper/keras_layers_Lambda",
  "/yolo_tf.YoloTensorflowWrapper/keras_layers_UpSampling2D",
  "/yolo_tf.YoloTensorflowWrapper/keras_layers_Concatenate",
  "/yolo_tf.YoloTensorflowWrapper/image_resize",
  "/yolo_tf.YoloTensorflowWrapper/keras_regularizers_l2",
  "/yolo_tf.YoloTensorflowWrapper/attribute_tensor_shape",
  "/yolo_tf.YoloTensorflowWrapper/attribute_model_load__weight",
  "/yolo_tf.YoloTensorflowWrapper/attribute_checkpoint_expect__partial",
  "/yolo_tf.YoloTensorflowWrapper/tensor_op_divide",
  "/yolo_tf.YoloTensorflowWrapper/iterable_indexing",
  "/yolo_tf.YoloTensorflowWrapper/byte_tensor_to_numpy",
  "/yolo_tf.YoloTensorflowWrapper/get_object_by_id",
  "/yolo_tf.YoloTensorflowWrapper/batch_normalization",
};

std::unique_ptr< YoloTensorflowWrapper::Stub> YoloTensorflowWrapper::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< YoloTensorflowWrapper::Stub> stub(new YoloTensorflowWrapper::Stub(channel));
  return stub;
}

YoloTensorflowWrapper::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_Connect_(YoloTensorflowWrapper_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Disconnect_(YoloTensorflowWrapper_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_SayHello_(YoloTensorflowWrapper_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_callable_emulator_(YoloTensorflowWrapper_method_names[3], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_get_iterable_slicing_(YoloTensorflowWrapper_method_names[4], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_constant_(YoloTensorflowWrapper_method_names[5], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_config_experimental_list__physical__devices_(YoloTensorflowWrapper_method_names[6], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_image_decode__image_(YoloTensorflowWrapper_method_names[7], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_expand__dims_(YoloTensorflowWrapper_method_names[8], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_keras_layers_Input_(YoloTensorflowWrapper_method_names[9], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_keras_Model_(YoloTensorflowWrapper_method_names[10], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_keras_layers_ZeroPadding2D_(YoloTensorflowWrapper_method_names[11], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_keras_layers_Conv2D_(YoloTensorflowWrapper_method_names[12], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_keras_layers_LeakyReLU_(YoloTensorflowWrapper_method_names[13], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_keras_layers_Add_(YoloTensorflowWrapper_method_names[14], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_keras_layers_Lambda_(YoloTensorflowWrapper_method_names[15], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_keras_layers_UpSampling2D_(YoloTensorflowWrapper_method_names[16], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_keras_layers_Concatenate_(YoloTensorflowWrapper_method_names[17], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_image_resize_(YoloTensorflowWrapper_method_names[18], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_keras_regularizers_l2_(YoloTensorflowWrapper_method_names[19], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_attribute_tensor_shape_(YoloTensorflowWrapper_method_names[20], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_attribute_model_load__weight_(YoloTensorflowWrapper_method_names[21], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_attribute_checkpoint_expect__partial_(YoloTensorflowWrapper_method_names[22], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_tensor_op_divide_(YoloTensorflowWrapper_method_names[23], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_iterable_indexing_(YoloTensorflowWrapper_method_names[24], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_byte_tensor_to_numpy_(YoloTensorflowWrapper_method_names[25], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_get_object_by_id_(YoloTensorflowWrapper_method_names[26], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_batch_normalization_(YoloTensorflowWrapper_method_names[27], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status YoloTensorflowWrapper::Stub::Connect(::grpc::ClientContext* context, const ::yolo_tf::ConnectRequest& request, ::yolo_tf::ConnectResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Connect_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::Connect(::grpc::ClientContext* context, const ::yolo_tf::ConnectRequest* request, ::yolo_tf::ConnectResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Connect_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::Connect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ConnectResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Connect_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::Connect(::grpc::ClientContext* context, const ::yolo_tf::ConnectRequest* request, ::yolo_tf::ConnectResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Connect_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::Connect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ConnectResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Connect_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::ConnectResponse>* YoloTensorflowWrapper::Stub::AsyncConnectRaw(::grpc::ClientContext* context, const ::yolo_tf::ConnectRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::ConnectResponse>::Create(channel_.get(), cq, rpcmethod_Connect_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::ConnectResponse>* YoloTensorflowWrapper::Stub::PrepareAsyncConnectRaw(::grpc::ClientContext* context, const ::yolo_tf::ConnectRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::ConnectResponse>::Create(channel_.get(), cq, rpcmethod_Connect_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::Disconnect(::grpc::ClientContext* context, const ::yolo_tf::DisconnectRequest& request, ::yolo_tf::DisconnectResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Disconnect_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::Disconnect(::grpc::ClientContext* context, const ::yolo_tf::DisconnectRequest* request, ::yolo_tf::DisconnectResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Disconnect_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::Disconnect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::DisconnectResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Disconnect_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::Disconnect(::grpc::ClientContext* context, const ::yolo_tf::DisconnectRequest* request, ::yolo_tf::DisconnectResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Disconnect_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::Disconnect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::DisconnectResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Disconnect_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::DisconnectResponse>* YoloTensorflowWrapper::Stub::AsyncDisconnectRaw(::grpc::ClientContext* context, const ::yolo_tf::DisconnectRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::DisconnectResponse>::Create(channel_.get(), cq, rpcmethod_Disconnect_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::DisconnectResponse>* YoloTensorflowWrapper::Stub::PrepareAsyncDisconnectRaw(::grpc::ClientContext* context, const ::yolo_tf::DisconnectRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::DisconnectResponse>::Create(channel_.get(), cq, rpcmethod_Disconnect_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::SayHello(::grpc::ClientContext* context, const ::yolo_tf::HelloRequest& request, ::yolo_tf::HelloReply* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_SayHello_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::SayHello(::grpc::ClientContext* context, const ::yolo_tf::HelloRequest* request, ::yolo_tf::HelloReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SayHello_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::SayHello(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::HelloReply* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_SayHello_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::SayHello(::grpc::ClientContext* context, const ::yolo_tf::HelloRequest* request, ::yolo_tf::HelloReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SayHello_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::SayHello(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::HelloReply* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_SayHello_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::HelloReply>* YoloTensorflowWrapper::Stub::AsyncSayHelloRaw(::grpc::ClientContext* context, const ::yolo_tf::HelloRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::HelloReply>::Create(channel_.get(), cq, rpcmethod_SayHello_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::HelloReply>* YoloTensorflowWrapper::Stub::PrepareAsyncSayHelloRaw(::grpc::ClientContext* context, const ::yolo_tf::HelloRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::HelloReply>::Create(channel_.get(), cq, rpcmethod_SayHello_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::callable_emulator(::grpc::ClientContext* context, const ::yolo_tf::CallRequest& request, ::yolo_tf::CallResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_callable_emulator_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::callable_emulator(::grpc::ClientContext* context, const ::yolo_tf::CallRequest* request, ::yolo_tf::CallResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_callable_emulator_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::callable_emulator(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::CallResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_callable_emulator_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::callable_emulator(::grpc::ClientContext* context, const ::yolo_tf::CallRequest* request, ::yolo_tf::CallResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_callable_emulator_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::callable_emulator(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::CallResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_callable_emulator_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::CallResponse>* YoloTensorflowWrapper::Stub::Asynccallable_emulatorRaw(::grpc::ClientContext* context, const ::yolo_tf::CallRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::CallResponse>::Create(channel_.get(), cq, rpcmethod_callable_emulator_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::CallResponse>* YoloTensorflowWrapper::Stub::PrepareAsynccallable_emulatorRaw(::grpc::ClientContext* context, const ::yolo_tf::CallRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::CallResponse>::Create(channel_.get(), cq, rpcmethod_callable_emulator_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::get_iterable_slicing(::grpc::ClientContext* context, const ::yolo_tf::SlicingRequest& request, ::yolo_tf::SlicingResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_get_iterable_slicing_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::get_iterable_slicing(::grpc::ClientContext* context, const ::yolo_tf::SlicingRequest* request, ::yolo_tf::SlicingResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_iterable_slicing_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::get_iterable_slicing(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::SlicingResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_iterable_slicing_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::get_iterable_slicing(::grpc::ClientContext* context, const ::yolo_tf::SlicingRequest* request, ::yolo_tf::SlicingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_iterable_slicing_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::get_iterable_slicing(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::SlicingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_iterable_slicing_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::SlicingResponse>* YoloTensorflowWrapper::Stub::Asyncget_iterable_slicingRaw(::grpc::ClientContext* context, const ::yolo_tf::SlicingRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::SlicingResponse>::Create(channel_.get(), cq, rpcmethod_get_iterable_slicing_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::SlicingResponse>* YoloTensorflowWrapper::Stub::PrepareAsyncget_iterable_slicingRaw(::grpc::ClientContext* context, const ::yolo_tf::SlicingRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::SlicingResponse>::Create(channel_.get(), cq, rpcmethod_get_iterable_slicing_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::constant(::grpc::ClientContext* context, const ::yolo_tf::ConstantRequest& request, ::yolo_tf::ConstantResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_constant_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::constant(::grpc::ClientContext* context, const ::yolo_tf::ConstantRequest* request, ::yolo_tf::ConstantResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_constant_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::constant(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ConstantResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_constant_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::constant(::grpc::ClientContext* context, const ::yolo_tf::ConstantRequest* request, ::yolo_tf::ConstantResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_constant_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::constant(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ConstantResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_constant_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::ConstantResponse>* YoloTensorflowWrapper::Stub::AsyncconstantRaw(::grpc::ClientContext* context, const ::yolo_tf::ConstantRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::ConstantResponse>::Create(channel_.get(), cq, rpcmethod_constant_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::ConstantResponse>* YoloTensorflowWrapper::Stub::PrepareAsyncconstantRaw(::grpc::ClientContext* context, const ::yolo_tf::ConstantRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::ConstantResponse>::Create(channel_.get(), cq, rpcmethod_constant_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::config_experimental_list__physical__devices(::grpc::ClientContext* context, const ::yolo_tf::DeviceType& request, ::yolo_tf::PhysicalDevices* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_config_experimental_list__physical__devices_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::config_experimental_list__physical__devices(::grpc::ClientContext* context, const ::yolo_tf::DeviceType* request, ::yolo_tf::PhysicalDevices* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_config_experimental_list__physical__devices_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::config_experimental_list__physical__devices(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::PhysicalDevices* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_config_experimental_list__physical__devices_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::config_experimental_list__physical__devices(::grpc::ClientContext* context, const ::yolo_tf::DeviceType* request, ::yolo_tf::PhysicalDevices* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_config_experimental_list__physical__devices_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::config_experimental_list__physical__devices(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::PhysicalDevices* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_config_experimental_list__physical__devices_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::PhysicalDevices>* YoloTensorflowWrapper::Stub::Asyncconfig_experimental_list__physical__devicesRaw(::grpc::ClientContext* context, const ::yolo_tf::DeviceType& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::PhysicalDevices>::Create(channel_.get(), cq, rpcmethod_config_experimental_list__physical__devices_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::PhysicalDevices>* YoloTensorflowWrapper::Stub::PrepareAsyncconfig_experimental_list__physical__devicesRaw(::grpc::ClientContext* context, const ::yolo_tf::DeviceType& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::PhysicalDevices>::Create(channel_.get(), cq, rpcmethod_config_experimental_list__physical__devices_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::image_decode__image(::grpc::ClientContext* context, const ::yolo_tf::DecodeImageRequest& request, ::yolo_tf::DecodeImageResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_image_decode__image_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::image_decode__image(::grpc::ClientContext* context, const ::yolo_tf::DecodeImageRequest* request, ::yolo_tf::DecodeImageResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_image_decode__image_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::image_decode__image(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::DecodeImageResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_image_decode__image_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::image_decode__image(::grpc::ClientContext* context, const ::yolo_tf::DecodeImageRequest* request, ::yolo_tf::DecodeImageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_image_decode__image_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::image_decode__image(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::DecodeImageResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_image_decode__image_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::DecodeImageResponse>* YoloTensorflowWrapper::Stub::Asyncimage_decode__imageRaw(::grpc::ClientContext* context, const ::yolo_tf::DecodeImageRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::DecodeImageResponse>::Create(channel_.get(), cq, rpcmethod_image_decode__image_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::DecodeImageResponse>* YoloTensorflowWrapper::Stub::PrepareAsyncimage_decode__imageRaw(::grpc::ClientContext* context, const ::yolo_tf::DecodeImageRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::DecodeImageResponse>::Create(channel_.get(), cq, rpcmethod_image_decode__image_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::expand__dims(::grpc::ClientContext* context, const ::yolo_tf::ExpandDemensionRequest& request, ::yolo_tf::ExpandDemensionResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_expand__dims_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::expand__dims(::grpc::ClientContext* context, const ::yolo_tf::ExpandDemensionRequest* request, ::yolo_tf::ExpandDemensionResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_expand__dims_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::expand__dims(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ExpandDemensionResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_expand__dims_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::expand__dims(::grpc::ClientContext* context, const ::yolo_tf::ExpandDemensionRequest* request, ::yolo_tf::ExpandDemensionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_expand__dims_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::expand__dims(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ExpandDemensionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_expand__dims_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::ExpandDemensionResponse>* YoloTensorflowWrapper::Stub::Asyncexpand__dimsRaw(::grpc::ClientContext* context, const ::yolo_tf::ExpandDemensionRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::ExpandDemensionResponse>::Create(channel_.get(), cq, rpcmethod_expand__dims_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::ExpandDemensionResponse>* YoloTensorflowWrapper::Stub::PrepareAsyncexpand__dimsRaw(::grpc::ClientContext* context, const ::yolo_tf::ExpandDemensionRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::ExpandDemensionResponse>::Create(channel_.get(), cq, rpcmethod_expand__dims_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::keras_layers_Input(::grpc::ClientContext* context, const ::yolo_tf::InputRequest& request, ::yolo_tf::InputResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_keras_layers_Input_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_Input(::grpc::ClientContext* context, const ::yolo_tf::InputRequest* request, ::yolo_tf::InputResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_keras_layers_Input_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_Input(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::InputResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_keras_layers_Input_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_Input(::grpc::ClientContext* context, const ::yolo_tf::InputRequest* request, ::yolo_tf::InputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_keras_layers_Input_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_Input(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::InputResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_keras_layers_Input_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::InputResponse>* YoloTensorflowWrapper::Stub::Asynckeras_layers_InputRaw(::grpc::ClientContext* context, const ::yolo_tf::InputRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::InputResponse>::Create(channel_.get(), cq, rpcmethod_keras_layers_Input_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::InputResponse>* YoloTensorflowWrapper::Stub::PrepareAsynckeras_layers_InputRaw(::grpc::ClientContext* context, const ::yolo_tf::InputRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::InputResponse>::Create(channel_.get(), cq, rpcmethod_keras_layers_Input_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::keras_Model(::grpc::ClientContext* context, const ::yolo_tf::ModelRequest& request, ::yolo_tf::ModelResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_keras_Model_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_Model(::grpc::ClientContext* context, const ::yolo_tf::ModelRequest* request, ::yolo_tf::ModelResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_keras_Model_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_Model(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ModelResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_keras_Model_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_Model(::grpc::ClientContext* context, const ::yolo_tf::ModelRequest* request, ::yolo_tf::ModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_keras_Model_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_Model(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ModelResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_keras_Model_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::ModelResponse>* YoloTensorflowWrapper::Stub::Asynckeras_ModelRaw(::grpc::ClientContext* context, const ::yolo_tf::ModelRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::ModelResponse>::Create(channel_.get(), cq, rpcmethod_keras_Model_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::ModelResponse>* YoloTensorflowWrapper::Stub::PrepareAsynckeras_ModelRaw(::grpc::ClientContext* context, const ::yolo_tf::ModelRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::ModelResponse>::Create(channel_.get(), cq, rpcmethod_keras_Model_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::keras_layers_ZeroPadding2D(::grpc::ClientContext* context, const ::yolo_tf::ZeroPadding2DRequest& request, ::yolo_tf::ZeroPadding2DResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_keras_layers_ZeroPadding2D_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_ZeroPadding2D(::grpc::ClientContext* context, const ::yolo_tf::ZeroPadding2DRequest* request, ::yolo_tf::ZeroPadding2DResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_keras_layers_ZeroPadding2D_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_ZeroPadding2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ZeroPadding2DResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_keras_layers_ZeroPadding2D_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_ZeroPadding2D(::grpc::ClientContext* context, const ::yolo_tf::ZeroPadding2DRequest* request, ::yolo_tf::ZeroPadding2DResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_keras_layers_ZeroPadding2D_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_ZeroPadding2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ZeroPadding2DResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_keras_layers_ZeroPadding2D_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::ZeroPadding2DResponse>* YoloTensorflowWrapper::Stub::Asynckeras_layers_ZeroPadding2DRaw(::grpc::ClientContext* context, const ::yolo_tf::ZeroPadding2DRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::ZeroPadding2DResponse>::Create(channel_.get(), cq, rpcmethod_keras_layers_ZeroPadding2D_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::ZeroPadding2DResponse>* YoloTensorflowWrapper::Stub::PrepareAsynckeras_layers_ZeroPadding2DRaw(::grpc::ClientContext* context, const ::yolo_tf::ZeroPadding2DRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::ZeroPadding2DResponse>::Create(channel_.get(), cq, rpcmethod_keras_layers_ZeroPadding2D_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::keras_layers_Conv2D(::grpc::ClientContext* context, const ::yolo_tf::Conv2DRequest& request, ::yolo_tf::Conv2DResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_keras_layers_Conv2D_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_Conv2D(::grpc::ClientContext* context, const ::yolo_tf::Conv2DRequest* request, ::yolo_tf::Conv2DResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_keras_layers_Conv2D_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_Conv2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::Conv2DResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_keras_layers_Conv2D_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_Conv2D(::grpc::ClientContext* context, const ::yolo_tf::Conv2DRequest* request, ::yolo_tf::Conv2DResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_keras_layers_Conv2D_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_Conv2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::Conv2DResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_keras_layers_Conv2D_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::Conv2DResponse>* YoloTensorflowWrapper::Stub::Asynckeras_layers_Conv2DRaw(::grpc::ClientContext* context, const ::yolo_tf::Conv2DRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::Conv2DResponse>::Create(channel_.get(), cq, rpcmethod_keras_layers_Conv2D_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::Conv2DResponse>* YoloTensorflowWrapper::Stub::PrepareAsynckeras_layers_Conv2DRaw(::grpc::ClientContext* context, const ::yolo_tf::Conv2DRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::Conv2DResponse>::Create(channel_.get(), cq, rpcmethod_keras_layers_Conv2D_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::keras_layers_LeakyReLU(::grpc::ClientContext* context, const ::yolo_tf::LeakyReluRequest& request, ::yolo_tf::LeakyReluResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_keras_layers_LeakyReLU_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_LeakyReLU(::grpc::ClientContext* context, const ::yolo_tf::LeakyReluRequest* request, ::yolo_tf::LeakyReluResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_keras_layers_LeakyReLU_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_LeakyReLU(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::LeakyReluResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_keras_layers_LeakyReLU_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_LeakyReLU(::grpc::ClientContext* context, const ::yolo_tf::LeakyReluRequest* request, ::yolo_tf::LeakyReluResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_keras_layers_LeakyReLU_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_LeakyReLU(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::LeakyReluResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_keras_layers_LeakyReLU_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::LeakyReluResponse>* YoloTensorflowWrapper::Stub::Asynckeras_layers_LeakyReLURaw(::grpc::ClientContext* context, const ::yolo_tf::LeakyReluRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::LeakyReluResponse>::Create(channel_.get(), cq, rpcmethod_keras_layers_LeakyReLU_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::LeakyReluResponse>* YoloTensorflowWrapper::Stub::PrepareAsynckeras_layers_LeakyReLURaw(::grpc::ClientContext* context, const ::yolo_tf::LeakyReluRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::LeakyReluResponse>::Create(channel_.get(), cq, rpcmethod_keras_layers_LeakyReLU_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::keras_layers_Add(::grpc::ClientContext* context, const ::yolo_tf::AddRequest& request, ::yolo_tf::AddResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_keras_layers_Add_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_Add(::grpc::ClientContext* context, const ::yolo_tf::AddRequest* request, ::yolo_tf::AddResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_keras_layers_Add_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_Add(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::AddResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_keras_layers_Add_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_Add(::grpc::ClientContext* context, const ::yolo_tf::AddRequest* request, ::yolo_tf::AddResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_keras_layers_Add_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_Add(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::AddResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_keras_layers_Add_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::AddResponse>* YoloTensorflowWrapper::Stub::Asynckeras_layers_AddRaw(::grpc::ClientContext* context, const ::yolo_tf::AddRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::AddResponse>::Create(channel_.get(), cq, rpcmethod_keras_layers_Add_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::AddResponse>* YoloTensorflowWrapper::Stub::PrepareAsynckeras_layers_AddRaw(::grpc::ClientContext* context, const ::yolo_tf::AddRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::AddResponse>::Create(channel_.get(), cq, rpcmethod_keras_layers_Add_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::keras_layers_Lambda(::grpc::ClientContext* context, const ::yolo_tf::LambdaRequest& request, ::yolo_tf::LambdaResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_keras_layers_Lambda_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_Lambda(::grpc::ClientContext* context, const ::yolo_tf::LambdaRequest* request, ::yolo_tf::LambdaResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_keras_layers_Lambda_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_Lambda(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::LambdaResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_keras_layers_Lambda_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_Lambda(::grpc::ClientContext* context, const ::yolo_tf::LambdaRequest* request, ::yolo_tf::LambdaResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_keras_layers_Lambda_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_Lambda(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::LambdaResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_keras_layers_Lambda_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::LambdaResponse>* YoloTensorflowWrapper::Stub::Asynckeras_layers_LambdaRaw(::grpc::ClientContext* context, const ::yolo_tf::LambdaRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::LambdaResponse>::Create(channel_.get(), cq, rpcmethod_keras_layers_Lambda_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::LambdaResponse>* YoloTensorflowWrapper::Stub::PrepareAsynckeras_layers_LambdaRaw(::grpc::ClientContext* context, const ::yolo_tf::LambdaRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::LambdaResponse>::Create(channel_.get(), cq, rpcmethod_keras_layers_Lambda_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::keras_layers_UpSampling2D(::grpc::ClientContext* context, const ::yolo_tf::UpSampling2DRequest& request, ::yolo_tf::UpSampling2DResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_keras_layers_UpSampling2D_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_UpSampling2D(::grpc::ClientContext* context, const ::yolo_tf::UpSampling2DRequest* request, ::yolo_tf::UpSampling2DResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_keras_layers_UpSampling2D_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_UpSampling2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::UpSampling2DResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_keras_layers_UpSampling2D_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_UpSampling2D(::grpc::ClientContext* context, const ::yolo_tf::UpSampling2DRequest* request, ::yolo_tf::UpSampling2DResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_keras_layers_UpSampling2D_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_UpSampling2D(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::UpSampling2DResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_keras_layers_UpSampling2D_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::UpSampling2DResponse>* YoloTensorflowWrapper::Stub::Asynckeras_layers_UpSampling2DRaw(::grpc::ClientContext* context, const ::yolo_tf::UpSampling2DRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::UpSampling2DResponse>::Create(channel_.get(), cq, rpcmethod_keras_layers_UpSampling2D_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::UpSampling2DResponse>* YoloTensorflowWrapper::Stub::PrepareAsynckeras_layers_UpSampling2DRaw(::grpc::ClientContext* context, const ::yolo_tf::UpSampling2DRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::UpSampling2DResponse>::Create(channel_.get(), cq, rpcmethod_keras_layers_UpSampling2D_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::keras_layers_Concatenate(::grpc::ClientContext* context, const ::yolo_tf::ConcatenateRequest& request, ::yolo_tf::ContcatenateResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_keras_layers_Concatenate_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_Concatenate(::grpc::ClientContext* context, const ::yolo_tf::ConcatenateRequest* request, ::yolo_tf::ContcatenateResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_keras_layers_Concatenate_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_Concatenate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ContcatenateResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_keras_layers_Concatenate_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_Concatenate(::grpc::ClientContext* context, const ::yolo_tf::ConcatenateRequest* request, ::yolo_tf::ContcatenateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_keras_layers_Concatenate_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_layers_Concatenate(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ContcatenateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_keras_layers_Concatenate_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::ContcatenateResponse>* YoloTensorflowWrapper::Stub::Asynckeras_layers_ConcatenateRaw(::grpc::ClientContext* context, const ::yolo_tf::ConcatenateRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::ContcatenateResponse>::Create(channel_.get(), cq, rpcmethod_keras_layers_Concatenate_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::ContcatenateResponse>* YoloTensorflowWrapper::Stub::PrepareAsynckeras_layers_ConcatenateRaw(::grpc::ClientContext* context, const ::yolo_tf::ConcatenateRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::ContcatenateResponse>::Create(channel_.get(), cq, rpcmethod_keras_layers_Concatenate_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::image_resize(::grpc::ClientContext* context, const ::yolo_tf::ImageResizeRequest& request, ::yolo_tf::ImageResizeResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_image_resize_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::image_resize(::grpc::ClientContext* context, const ::yolo_tf::ImageResizeRequest* request, ::yolo_tf::ImageResizeResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_image_resize_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::image_resize(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ImageResizeResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_image_resize_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::image_resize(::grpc::ClientContext* context, const ::yolo_tf::ImageResizeRequest* request, ::yolo_tf::ImageResizeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_image_resize_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::image_resize(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ImageResizeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_image_resize_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::ImageResizeResponse>* YoloTensorflowWrapper::Stub::Asyncimage_resizeRaw(::grpc::ClientContext* context, const ::yolo_tf::ImageResizeRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::ImageResizeResponse>::Create(channel_.get(), cq, rpcmethod_image_resize_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::ImageResizeResponse>* YoloTensorflowWrapper::Stub::PrepareAsyncimage_resizeRaw(::grpc::ClientContext* context, const ::yolo_tf::ImageResizeRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::ImageResizeResponse>::Create(channel_.get(), cq, rpcmethod_image_resize_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::keras_regularizers_l2(::grpc::ClientContext* context, const ::yolo_tf::l2Request& request, ::yolo_tf::l2Response* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_keras_regularizers_l2_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_regularizers_l2(::grpc::ClientContext* context, const ::yolo_tf::l2Request* request, ::yolo_tf::l2Response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_keras_regularizers_l2_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_regularizers_l2(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::l2Response* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_keras_regularizers_l2_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_regularizers_l2(::grpc::ClientContext* context, const ::yolo_tf::l2Request* request, ::yolo_tf::l2Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_keras_regularizers_l2_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::keras_regularizers_l2(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::l2Response* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_keras_regularizers_l2_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::l2Response>* YoloTensorflowWrapper::Stub::Asynckeras_regularizers_l2Raw(::grpc::ClientContext* context, const ::yolo_tf::l2Request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::l2Response>::Create(channel_.get(), cq, rpcmethod_keras_regularizers_l2_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::l2Response>* YoloTensorflowWrapper::Stub::PrepareAsynckeras_regularizers_l2Raw(::grpc::ClientContext* context, const ::yolo_tf::l2Request& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::l2Response>::Create(channel_.get(), cq, rpcmethod_keras_regularizers_l2_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::attribute_tensor_shape(::grpc::ClientContext* context, const ::yolo_tf::TensorShapeRequest& request, ::yolo_tf::TensorShapeResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_attribute_tensor_shape_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::attribute_tensor_shape(::grpc::ClientContext* context, const ::yolo_tf::TensorShapeRequest* request, ::yolo_tf::TensorShapeResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_attribute_tensor_shape_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::attribute_tensor_shape(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::TensorShapeResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_attribute_tensor_shape_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::attribute_tensor_shape(::grpc::ClientContext* context, const ::yolo_tf::TensorShapeRequest* request, ::yolo_tf::TensorShapeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_attribute_tensor_shape_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::attribute_tensor_shape(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::TensorShapeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_attribute_tensor_shape_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::TensorShapeResponse>* YoloTensorflowWrapper::Stub::Asyncattribute_tensor_shapeRaw(::grpc::ClientContext* context, const ::yolo_tf::TensorShapeRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::TensorShapeResponse>::Create(channel_.get(), cq, rpcmethod_attribute_tensor_shape_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::TensorShapeResponse>* YoloTensorflowWrapper::Stub::PrepareAsyncattribute_tensor_shapeRaw(::grpc::ClientContext* context, const ::yolo_tf::TensorShapeRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::TensorShapeResponse>::Create(channel_.get(), cq, rpcmethod_attribute_tensor_shape_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::attribute_model_load__weight(::grpc::ClientContext* context, const ::yolo_tf::LoadWeightsRequest& request, ::yolo_tf::LoadWeightsResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_attribute_model_load__weight_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::attribute_model_load__weight(::grpc::ClientContext* context, const ::yolo_tf::LoadWeightsRequest* request, ::yolo_tf::LoadWeightsResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_attribute_model_load__weight_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::attribute_model_load__weight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::LoadWeightsResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_attribute_model_load__weight_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::attribute_model_load__weight(::grpc::ClientContext* context, const ::yolo_tf::LoadWeightsRequest* request, ::yolo_tf::LoadWeightsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_attribute_model_load__weight_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::attribute_model_load__weight(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::LoadWeightsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_attribute_model_load__weight_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::LoadWeightsResponse>* YoloTensorflowWrapper::Stub::Asyncattribute_model_load__weightRaw(::grpc::ClientContext* context, const ::yolo_tf::LoadWeightsRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::LoadWeightsResponse>::Create(channel_.get(), cq, rpcmethod_attribute_model_load__weight_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::LoadWeightsResponse>* YoloTensorflowWrapper::Stub::PrepareAsyncattribute_model_load__weightRaw(::grpc::ClientContext* context, const ::yolo_tf::LoadWeightsRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::LoadWeightsResponse>::Create(channel_.get(), cq, rpcmethod_attribute_model_load__weight_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::attribute_checkpoint_expect__partial(::grpc::ClientContext* context, const ::yolo_tf::ExpectPartialRequest& request, ::yolo_tf::ExpectPartialResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_attribute_checkpoint_expect__partial_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::attribute_checkpoint_expect__partial(::grpc::ClientContext* context, const ::yolo_tf::ExpectPartialRequest* request, ::yolo_tf::ExpectPartialResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_attribute_checkpoint_expect__partial_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::attribute_checkpoint_expect__partial(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ExpectPartialResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_attribute_checkpoint_expect__partial_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::attribute_checkpoint_expect__partial(::grpc::ClientContext* context, const ::yolo_tf::ExpectPartialRequest* request, ::yolo_tf::ExpectPartialResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_attribute_checkpoint_expect__partial_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::attribute_checkpoint_expect__partial(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::ExpectPartialResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_attribute_checkpoint_expect__partial_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::ExpectPartialResponse>* YoloTensorflowWrapper::Stub::Asyncattribute_checkpoint_expect__partialRaw(::grpc::ClientContext* context, const ::yolo_tf::ExpectPartialRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::ExpectPartialResponse>::Create(channel_.get(), cq, rpcmethod_attribute_checkpoint_expect__partial_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::ExpectPartialResponse>* YoloTensorflowWrapper::Stub::PrepareAsyncattribute_checkpoint_expect__partialRaw(::grpc::ClientContext* context, const ::yolo_tf::ExpectPartialRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::ExpectPartialResponse>::Create(channel_.get(), cq, rpcmethod_attribute_checkpoint_expect__partial_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::tensor_op_divide(::grpc::ClientContext* context, const ::yolo_tf::DivideRequest& request, ::yolo_tf::DivideResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_tensor_op_divide_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::tensor_op_divide(::grpc::ClientContext* context, const ::yolo_tf::DivideRequest* request, ::yolo_tf::DivideResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_tensor_op_divide_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::tensor_op_divide(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::DivideResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_tensor_op_divide_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::tensor_op_divide(::grpc::ClientContext* context, const ::yolo_tf::DivideRequest* request, ::yolo_tf::DivideResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_tensor_op_divide_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::tensor_op_divide(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::DivideResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_tensor_op_divide_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::DivideResponse>* YoloTensorflowWrapper::Stub::Asynctensor_op_divideRaw(::grpc::ClientContext* context, const ::yolo_tf::DivideRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::DivideResponse>::Create(channel_.get(), cq, rpcmethod_tensor_op_divide_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::DivideResponse>* YoloTensorflowWrapper::Stub::PrepareAsynctensor_op_divideRaw(::grpc::ClientContext* context, const ::yolo_tf::DivideRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::DivideResponse>::Create(channel_.get(), cq, rpcmethod_tensor_op_divide_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::iterable_indexing(::grpc::ClientContext* context, const ::yolo_tf::IndexingRequest& request, ::yolo_tf::IndexingResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_iterable_indexing_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::iterable_indexing(::grpc::ClientContext* context, const ::yolo_tf::IndexingRequest* request, ::yolo_tf::IndexingResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_iterable_indexing_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::iterable_indexing(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::IndexingResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_iterable_indexing_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::iterable_indexing(::grpc::ClientContext* context, const ::yolo_tf::IndexingRequest* request, ::yolo_tf::IndexingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_iterable_indexing_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::iterable_indexing(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::IndexingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_iterable_indexing_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::IndexingResponse>* YoloTensorflowWrapper::Stub::Asynciterable_indexingRaw(::grpc::ClientContext* context, const ::yolo_tf::IndexingRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::IndexingResponse>::Create(channel_.get(), cq, rpcmethod_iterable_indexing_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::IndexingResponse>* YoloTensorflowWrapper::Stub::PrepareAsynciterable_indexingRaw(::grpc::ClientContext* context, const ::yolo_tf::IndexingRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::IndexingResponse>::Create(channel_.get(), cq, rpcmethod_iterable_indexing_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::byte_tensor_to_numpy(::grpc::ClientContext* context, const ::yolo_tf::TensorToNumpyRequest& request, ::yolo_tf::TensorToNumPyResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_byte_tensor_to_numpy_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::byte_tensor_to_numpy(::grpc::ClientContext* context, const ::yolo_tf::TensorToNumpyRequest* request, ::yolo_tf::TensorToNumPyResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_byte_tensor_to_numpy_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::byte_tensor_to_numpy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::TensorToNumPyResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_byte_tensor_to_numpy_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::byte_tensor_to_numpy(::grpc::ClientContext* context, const ::yolo_tf::TensorToNumpyRequest* request, ::yolo_tf::TensorToNumPyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_byte_tensor_to_numpy_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::byte_tensor_to_numpy(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::TensorToNumPyResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_byte_tensor_to_numpy_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::TensorToNumPyResponse>* YoloTensorflowWrapper::Stub::Asyncbyte_tensor_to_numpyRaw(::grpc::ClientContext* context, const ::yolo_tf::TensorToNumpyRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::TensorToNumPyResponse>::Create(channel_.get(), cq, rpcmethod_byte_tensor_to_numpy_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::TensorToNumPyResponse>* YoloTensorflowWrapper::Stub::PrepareAsyncbyte_tensor_to_numpyRaw(::grpc::ClientContext* context, const ::yolo_tf::TensorToNumpyRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::TensorToNumPyResponse>::Create(channel_.get(), cq, rpcmethod_byte_tensor_to_numpy_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::get_object_by_id(::grpc::ClientContext* context, const ::yolo_tf::GetObjectRequest& request, ::yolo_tf::GetObjectResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_get_object_by_id_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::get_object_by_id(::grpc::ClientContext* context, const ::yolo_tf::GetObjectRequest* request, ::yolo_tf::GetObjectResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_object_by_id_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::get_object_by_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::GetObjectResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_get_object_by_id_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::get_object_by_id(::grpc::ClientContext* context, const ::yolo_tf::GetObjectRequest* request, ::yolo_tf::GetObjectResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_object_by_id_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::get_object_by_id(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::GetObjectResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_get_object_by_id_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::GetObjectResponse>* YoloTensorflowWrapper::Stub::Asyncget_object_by_idRaw(::grpc::ClientContext* context, const ::yolo_tf::GetObjectRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::GetObjectResponse>::Create(channel_.get(), cq, rpcmethod_get_object_by_id_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::GetObjectResponse>* YoloTensorflowWrapper::Stub::PrepareAsyncget_object_by_idRaw(::grpc::ClientContext* context, const ::yolo_tf::GetObjectRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::GetObjectResponse>::Create(channel_.get(), cq, rpcmethod_get_object_by_id_, context, request, false);
}

::grpc::Status YoloTensorflowWrapper::Stub::batch_normalization(::grpc::ClientContext* context, const ::yolo_tf::BatchNormRequest& request, ::yolo_tf::BatchNormResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_batch_normalization_, context, request, response);
}

void YoloTensorflowWrapper::Stub::experimental_async::batch_normalization(::grpc::ClientContext* context, const ::yolo_tf::BatchNormRequest* request, ::yolo_tf::BatchNormResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_batch_normalization_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::batch_normalization(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::BatchNormResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_batch_normalization_, context, request, response, std::move(f));
}

void YoloTensorflowWrapper::Stub::experimental_async::batch_normalization(::grpc::ClientContext* context, const ::yolo_tf::BatchNormRequest* request, ::yolo_tf::BatchNormResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_batch_normalization_, context, request, response, reactor);
}

void YoloTensorflowWrapper::Stub::experimental_async::batch_normalization(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::yolo_tf::BatchNormResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_batch_normalization_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::BatchNormResponse>* YoloTensorflowWrapper::Stub::Asyncbatch_normalizationRaw(::grpc::ClientContext* context, const ::yolo_tf::BatchNormRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::BatchNormResponse>::Create(channel_.get(), cq, rpcmethod_batch_normalization_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::yolo_tf::BatchNormResponse>* YoloTensorflowWrapper::Stub::PrepareAsyncbatch_normalizationRaw(::grpc::ClientContext* context, const ::yolo_tf::BatchNormRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::yolo_tf::BatchNormResponse>::Create(channel_.get(), cq, rpcmethod_batch_normalization_, context, request, false);
}

YoloTensorflowWrapper::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::ConnectRequest, ::yolo_tf::ConnectResponse>(
          std::mem_fn(&YoloTensorflowWrapper::Service::Connect), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::DisconnectRequest, ::yolo_tf::DisconnectResponse>(
          std::mem_fn(&YoloTensorflowWrapper::Service::Disconnect), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::HelloRequest, ::yolo_tf::HelloReply>(
          std::mem_fn(&YoloTensorflowWrapper::Service::SayHello), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::CallRequest, ::yolo_tf::CallResponse>(
          std::mem_fn(&YoloTensorflowWrapper::Service::callable_emulator), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::SlicingRequest, ::yolo_tf::SlicingResponse>(
          std::mem_fn(&YoloTensorflowWrapper::Service::get_iterable_slicing), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::ConstantRequest, ::yolo_tf::ConstantResponse>(
          std::mem_fn(&YoloTensorflowWrapper::Service::constant), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[6],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::DeviceType, ::yolo_tf::PhysicalDevices>(
          std::mem_fn(&YoloTensorflowWrapper::Service::config_experimental_list__physical__devices), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[7],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::DecodeImageRequest, ::yolo_tf::DecodeImageResponse>(
          std::mem_fn(&YoloTensorflowWrapper::Service::image_decode__image), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[8],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::ExpandDemensionRequest, ::yolo_tf::ExpandDemensionResponse>(
          std::mem_fn(&YoloTensorflowWrapper::Service::expand__dims), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[9],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::InputRequest, ::yolo_tf::InputResponse>(
          std::mem_fn(&YoloTensorflowWrapper::Service::keras_layers_Input), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[10],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::ModelRequest, ::yolo_tf::ModelResponse>(
          std::mem_fn(&YoloTensorflowWrapper::Service::keras_Model), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[11],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::ZeroPadding2DRequest, ::yolo_tf::ZeroPadding2DResponse>(
          std::mem_fn(&YoloTensorflowWrapper::Service::keras_layers_ZeroPadding2D), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[12],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::Conv2DRequest, ::yolo_tf::Conv2DResponse>(
          std::mem_fn(&YoloTensorflowWrapper::Service::keras_layers_Conv2D), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[13],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::LeakyReluRequest, ::yolo_tf::LeakyReluResponse>(
          std::mem_fn(&YoloTensorflowWrapper::Service::keras_layers_LeakyReLU), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[14],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::AddRequest, ::yolo_tf::AddResponse>(
          std::mem_fn(&YoloTensorflowWrapper::Service::keras_layers_Add), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[15],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::LambdaRequest, ::yolo_tf::LambdaResponse>(
          std::mem_fn(&YoloTensorflowWrapper::Service::keras_layers_Lambda), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[16],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::UpSampling2DRequest, ::yolo_tf::UpSampling2DResponse>(
          std::mem_fn(&YoloTensorflowWrapper::Service::keras_layers_UpSampling2D), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[17],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::ConcatenateRequest, ::yolo_tf::ContcatenateResponse>(
          std::mem_fn(&YoloTensorflowWrapper::Service::keras_layers_Concatenate), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[18],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::ImageResizeRequest, ::yolo_tf::ImageResizeResponse>(
          std::mem_fn(&YoloTensorflowWrapper::Service::image_resize), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[19],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::l2Request, ::yolo_tf::l2Response>(
          std::mem_fn(&YoloTensorflowWrapper::Service::keras_regularizers_l2), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[20],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::TensorShapeRequest, ::yolo_tf::TensorShapeResponse>(
          std::mem_fn(&YoloTensorflowWrapper::Service::attribute_tensor_shape), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[21],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::LoadWeightsRequest, ::yolo_tf::LoadWeightsResponse>(
          std::mem_fn(&YoloTensorflowWrapper::Service::attribute_model_load__weight), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[22],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::ExpectPartialRequest, ::yolo_tf::ExpectPartialResponse>(
          std::mem_fn(&YoloTensorflowWrapper::Service::attribute_checkpoint_expect__partial), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[23],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::DivideRequest, ::yolo_tf::DivideResponse>(
          std::mem_fn(&YoloTensorflowWrapper::Service::tensor_op_divide), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[24],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::IndexingRequest, ::yolo_tf::IndexingResponse>(
          std::mem_fn(&YoloTensorflowWrapper::Service::iterable_indexing), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[25],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::TensorToNumpyRequest, ::yolo_tf::TensorToNumPyResponse>(
          std::mem_fn(&YoloTensorflowWrapper::Service::byte_tensor_to_numpy), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[26],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::GetObjectRequest, ::yolo_tf::GetObjectResponse>(
          std::mem_fn(&YoloTensorflowWrapper::Service::get_object_by_id), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      YoloTensorflowWrapper_method_names[27],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< YoloTensorflowWrapper::Service, ::yolo_tf::BatchNormRequest, ::yolo_tf::BatchNormResponse>(
          std::mem_fn(&YoloTensorflowWrapper::Service::batch_normalization), this)));
}

YoloTensorflowWrapper::Service::~Service() {
}

::grpc::Status YoloTensorflowWrapper::Service::Connect(::grpc::ServerContext* context, const ::yolo_tf::ConnectRequest* request, ::yolo_tf::ConnectResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::Disconnect(::grpc::ServerContext* context, const ::yolo_tf::DisconnectRequest* request, ::yolo_tf::DisconnectResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::SayHello(::grpc::ServerContext* context, const ::yolo_tf::HelloRequest* request, ::yolo_tf::HelloReply* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::callable_emulator(::grpc::ServerContext* context, const ::yolo_tf::CallRequest* request, ::yolo_tf::CallResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::get_iterable_slicing(::grpc::ServerContext* context, const ::yolo_tf::SlicingRequest* request, ::yolo_tf::SlicingResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::constant(::grpc::ServerContext* context, const ::yolo_tf::ConstantRequest* request, ::yolo_tf::ConstantResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::config_experimental_list__physical__devices(::grpc::ServerContext* context, const ::yolo_tf::DeviceType* request, ::yolo_tf::PhysicalDevices* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::image_decode__image(::grpc::ServerContext* context, const ::yolo_tf::DecodeImageRequest* request, ::yolo_tf::DecodeImageResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::expand__dims(::grpc::ServerContext* context, const ::yolo_tf::ExpandDemensionRequest* request, ::yolo_tf::ExpandDemensionResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::keras_layers_Input(::grpc::ServerContext* context, const ::yolo_tf::InputRequest* request, ::yolo_tf::InputResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::keras_Model(::grpc::ServerContext* context, const ::yolo_tf::ModelRequest* request, ::yolo_tf::ModelResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::keras_layers_ZeroPadding2D(::grpc::ServerContext* context, const ::yolo_tf::ZeroPadding2DRequest* request, ::yolo_tf::ZeroPadding2DResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::keras_layers_Conv2D(::grpc::ServerContext* context, const ::yolo_tf::Conv2DRequest* request, ::yolo_tf::Conv2DResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::keras_layers_LeakyReLU(::grpc::ServerContext* context, const ::yolo_tf::LeakyReluRequest* request, ::yolo_tf::LeakyReluResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::keras_layers_Add(::grpc::ServerContext* context, const ::yolo_tf::AddRequest* request, ::yolo_tf::AddResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::keras_layers_Lambda(::grpc::ServerContext* context, const ::yolo_tf::LambdaRequest* request, ::yolo_tf::LambdaResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::keras_layers_UpSampling2D(::grpc::ServerContext* context, const ::yolo_tf::UpSampling2DRequest* request, ::yolo_tf::UpSampling2DResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::keras_layers_Concatenate(::grpc::ServerContext* context, const ::yolo_tf::ConcatenateRequest* request, ::yolo_tf::ContcatenateResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::image_resize(::grpc::ServerContext* context, const ::yolo_tf::ImageResizeRequest* request, ::yolo_tf::ImageResizeResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::keras_regularizers_l2(::grpc::ServerContext* context, const ::yolo_tf::l2Request* request, ::yolo_tf::l2Response* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::attribute_tensor_shape(::grpc::ServerContext* context, const ::yolo_tf::TensorShapeRequest* request, ::yolo_tf::TensorShapeResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::attribute_model_load__weight(::grpc::ServerContext* context, const ::yolo_tf::LoadWeightsRequest* request, ::yolo_tf::LoadWeightsResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::attribute_checkpoint_expect__partial(::grpc::ServerContext* context, const ::yolo_tf::ExpectPartialRequest* request, ::yolo_tf::ExpectPartialResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::tensor_op_divide(::grpc::ServerContext* context, const ::yolo_tf::DivideRequest* request, ::yolo_tf::DivideResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::iterable_indexing(::grpc::ServerContext* context, const ::yolo_tf::IndexingRequest* request, ::yolo_tf::IndexingResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::byte_tensor_to_numpy(::grpc::ServerContext* context, const ::yolo_tf::TensorToNumpyRequest* request, ::yolo_tf::TensorToNumPyResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::get_object_by_id(::grpc::ServerContext* context, const ::yolo_tf::GetObjectRequest* request, ::yolo_tf::GetObjectResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status YoloTensorflowWrapper::Service::batch_normalization(::grpc::ServerContext* context, const ::yolo_tf::BatchNormRequest* request, ::yolo_tf::BatchNormResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace yolo_tf

